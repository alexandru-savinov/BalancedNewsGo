
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/alexandru-savinov/BalancedNewsGo/internal/api/api.go (0.0%)</option>
				
				<option value="file1">github.com/alexandru-savinov/BalancedNewsGo/internal/api/cache.go (6.2%)</option>
				
				<option value="file2">github.com/alexandru-savinov/BalancedNewsGo/internal/api/debug_handler.go (0.0%)</option>
				
				<option value="file3">github.com/alexandru-savinov/BalancedNewsGo/internal/api/errors.go (71.4%)</option>
				
				<option value="file4">github.com/alexandru-savinov/BalancedNewsGo/internal/api/handlers.go (75.9%)</option>
				
				<option value="file5">github.com/alexandru-savinov/BalancedNewsGo/internal/api/response.go (50.0%)</option>
				
				<option value="file6">github.com/alexandru-savinov/BalancedNewsGo/internal/db/db.go (59.6%)</option>
				
				<option value="file7">github.com/alexandru-savinov/BalancedNewsGo/internal/llm/cache.go (86.7%)</option>
				
				<option value="file8">github.com/alexandru-savinov/BalancedNewsGo/internal/llm/composite_score_fix.go (80.6%)</option>
				
				<option value="file9">github.com/alexandru-savinov/BalancedNewsGo/internal/llm/composite_score_utils.go (82.9%)</option>
				
				<option value="file10">github.com/alexandru-savinov/BalancedNewsGo/internal/llm/ensemble.go (18.6%)</option>
				
				<option value="file11">github.com/alexandru-savinov/BalancedNewsGo/internal/llm/llm.go (39.9%)</option>
				
				<option value="file12">github.com/alexandru-savinov/BalancedNewsGo/internal/llm/progress_manager.go (95.5%)</option>
				
				<option value="file13">github.com/alexandru-savinov/BalancedNewsGo/internal/llm/score_calculator.go (91.1%)</option>
				
				<option value="file14">github.com/alexandru-savinov/BalancedNewsGo/internal/llm/score_manager.go (12.0%)</option>
				
				<option value="file15">github.com/alexandru-savinov/BalancedNewsGo/internal/llm/service_http.go (87.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "math"
        "net/http"
        "runtime/debug"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
        "github.com/alexandru-savinov/BalancedNewsGo/internal/llm"
        "github.com/alexandru-savinov/BalancedNewsGo/internal/models"
        "github.com/alexandru-savinov/BalancedNewsGo/internal/rss"
        "github.com/gin-gonic/gin"
        "github.com/jmoiron/sqlx"
)

var (
        articlesCache     = NewSimpleCache()
        articlesCacheLock sync.RWMutex
)

// Progress tracking vars
var (
        progressMap     = make(map[int64]*models.ProgressState)
        progressMapLock sync.RWMutex
)

func setProgress(articleID int64, state *models.ProgressState) <span class="cov0" title="0">{
        progressMapLock.Lock()
        defer progressMapLock.Unlock()
        progressMap[articleID] = state
        log.Printf("[SetProgress] ArticleID=%d Status=%s Step=%s Message=%s",
                articleID, state.Status, state.Step, state.Message)
}</span>

func getProgress(articleID int64) *models.ProgressState <span class="cov0" title="0">{
        progressMapLock.RLock()
        defer progressMapLock.RUnlock()
        if p, ok := progressMap[articleID]; ok </span><span class="cov0" title="0">{
                return p
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RegisterRoutes registers all API routes on the provided router
func RegisterRoutes(router *gin.Engine, dbConn *sqlx.DB, rssCollector *rss.Collector, llmClient *llm.LLMClient, scoreManager *llm.ScoreManager) <span class="cov0" title="0">{
        // Articles endpoints
        // @Summary Get all articles
        // @Description Get a list of all articles with optional filtering
        // @Tags Articles
        // @Accept json
        // @Produce json
        // @Param source query string false "Filter by news source"
        // @Param offset query integer false "Pagination offset"
        // @Param limit query integer false "Number of items per page"
        // @Success 200 {array} models.Article
        // @Failure 500 {object} ErrorResponse
        // @Router /articles [get]
        router.GET("/api/articles", SafeHandler(getArticlesHandler(dbConn)))

        // @Summary Get article by ID
        // @Description Get detailed information about a specific article
        // @Tags Articles
        // @Accept json
        // @Produce json
        // @Param id path integer true "Article ID"
        // @Success 200 {object} models.Article
        // @Failure 404 {object} ErrorResponse
        // @Router /articles/{id} [get]
        router.GET("/api/articles/:id", SafeHandler(getArticleByIDHandler(dbConn)))

        // @Summary Create article
        // @Description Create a new article
        // @Tags Articles
        // @Accept json
        // @Produce json
        // @Param article body models.CreateArticleRequest true "Article object"
        // @Success 200 {object} StandardResponse{data=models.Article}
        // @Failure 400 {object} ErrorResponse
        // @Router /articles [post]
        router.POST("/api/articles", SafeHandler(createArticleHandler(dbConn)))

        // Feed management
        // @Summary Refresh feeds
        // @Description Trigger a refresh of all RSS feeds
        // @Tags Feeds
        // @Accept json
        // @Produce json
        // @Success 200 {object} StandardResponse
        // @Failure 500 {object} ErrorResponse
        // @Router /refresh [post]
        router.POST("/api/refresh", SafeHandler(refreshHandler(rssCollector)))

        // LLM Analysis
        // @Summary Reanalyze article
        // @Description Trigger a new LLM analysis for a specific article
        // @Tags LLM
        // @Accept json
        // @Produce json
        // @Param id path integer true "Article ID"
        // @Success 202 {object} StandardResponse
        // @Failure 404 {object} ErrorResponse
        // @Router /llm/reanalyze/{id} [post]
        router.POST("/api/llm/reanalyze/:id", SafeHandler(reanalyzeHandler(llmClient, dbConn, scoreManager)))

        // Scoring
        // @Summary Add manual score
        // @Description Add a manual bias score for an article
        // @Tags Scoring
        // @Accept json
        // @Produce json
        // @Param id path integer true "Article ID"
        // @Param score body models.ManualScoreRequest true "Score information"
        // @Success 200 {object} StandardResponse
        // @Failure 400 {object} ErrorResponse
        // @Router /manual-score/{id} [post]
        router.POST("/api/manual-score/:id", SafeHandler(manualScoreHandler(dbConn)))

        // Article analysis
        // @Summary Get article summary
        // @Description Get the summary analysis for an article
        // @Tags Analysis
        // @Accept json
        // @Produce json
        // @Param id path integer true "Article ID"
        // @Success 200 {object} models.SummaryResponse
        // @Failure 404 {object} ErrorResponse
        // @Router /articles/{id}/summary [get]
        router.GET("/api/articles/:id/summary", SafeHandler(summaryHandler(dbConn)))

        // @Summary Get bias analysis
        // @Description Get the bias analysis for an article
        // @Tags Analysis
        // @Accept json
        // @Produce json
        // @Param id path integer true "Article ID"
        // @Success 200 {object} models.BiasResponse
        // @Failure 404 {object} ErrorResponse
        // @Router /articles/{id}/bias [get]
        router.GET("/api/articles/:id/bias", SafeHandler(biasHandler(dbConn)))

        // @Summary Get ensemble details
        // @Description Get detailed ensemble analysis results for an article
        // @Tags Analysis
        // @Param id path integer true "Article ID"
        // @Success 200 {object} models.EnsembleResponse
        // @Failure 404 {object} ErrorResponse
        // @Router /articles/{id}/ensemble [get]
        router.GET("/api/articles/:id/ensemble", SafeHandler(ensembleDetailsHandler(dbConn)))

        // Feedback
        // @Summary Submit feedback
        // @Description Submit user feedback for an article analysis
        // @Tags Feedback
        // @Accept json
        // @Produce json
        // @Param feedback body models.FeedbackRequest true "Feedback information"
        // @Success 200 {object} StandardResponse
        // @Failure 400 {object} ErrorResponse
        // @Router /feedback [post]
        router.POST("/api/feedback", SafeHandler(feedbackHandler(dbConn)))

        // Health checks
        // @Summary Feed health check
        // @Description Check the health status of RSS feeds
        // @Tags Health
        // @Accept json
        // @Produce json
        // @Success 200 {object} StandardResponse
        // @Router /feeds/healthz [get]
        router.GET("/api/feeds/healthz", SafeHandler(feedHealthHandler(rssCollector)))

        // Progress tracking
        // @Summary Score progress
        // @Description Get real-time progress updates for article scoring
        // @Tags LLM
        // @Accept json
        // @Produce text/event-stream
        // @Param id path integer true "Article ID"
        // @Success 200 {object} models.ProgressResponse
        // @Router /llm/score-progress/{id} [get]
        router.GET("/api/llm/score-progress/:id", SafeHandler(scoreProgressSSEHandler()))
}</span>

// SafeHandler wraps a handler function with panic recovery to prevent server crashes
func SafeHandler(handler gin.HandlerFunc) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                // Log the panic
                                log.Printf("[PANIC RECOVERED] %v\n%s", r, string(debug.Stack()))
                                // Return an error response
                                RespondError(c, NewAppError(ErrInternal, fmt.Sprintf("Internal server error: %v", r)))
                        }</span>
                }()
                <span class="cov0" title="0">handler(c)</span>
        }
}

// Helper: Convert db.Article to Postman schema (TitleCase fields)
func articleToPostmanSchema(a *db.Article) map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "article_id":     a.ID,
                "Title":          a.Title,
                "Content":        a.Content,
                "URL":            a.URL,
                "Source":         a.Source,
                "CompositeScore": a.CompositeScore,
                "Confidence":     a.Confidence,
        }
}</span>

// Handler for POST /api/articles
// @Summary Create article
// @Description Creates a new article with the provided information
// @Tags Articles
// @Accept json
// @Produce json
// @Param request body CreateArticleRequest true "Article information"
// @Success 200 {object} StandardResponse{data=CreateArticleResponse} "Article created successfully"
// @Failure 400 {object} ErrorResponse "Invalid request data"
// @Failure 409 {object} ErrorResponse "Article URL already exists"
// @Failure 500 {object} ErrorResponse "Server error"
// @Router /articles [post]
func createArticleHandler(dbConn *sqlx.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                var req struct {
                        Source  string `json:"source"`
                        PubDate string `json:"pub_date"`
                        URL     string `json:"url"`
                        Title   string `json:"title"`
                        Content string `json:"content"`
                }
                decoder := json.NewDecoder(c.Request.Body)
                decoder.DisallowUnknownFields()
                if err := decoder.Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), "unknown field") </span><span class="cov0" title="0">{
                                RespondError(c, NewAppError(ErrValidation, "Request contains unknown or extra fields"))
                                return
                        }</span>
                        <span class="cov0" title="0">RespondError(c, ErrInvalidPayload)
                        return</span>
                }

                // Validate required fields
                <span class="cov0" title="0">var missingFields []string
                if req.Source == "" </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, "source")
                }</span>
                <span class="cov0" title="0">if req.URL == "" </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, "url")
                }</span>
                <span class="cov0" title="0">if req.Title == "" </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, "title")
                }</span>
                <span class="cov0" title="0">if req.Content == "" </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, "content")
                }</span>
                <span class="cov0" title="0">if req.PubDate == "" </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, "pub_date")
                }</span>

                <span class="cov0" title="0">if len(missingFields) &gt; 0 </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation,
                                fmt.Sprintf("Missing required fields: %s", strings.Join(missingFields, ", "))))
                        return
                }</span>

                // Validate URL format
                <span class="cov0" title="0">if !strings.HasPrefix(req.URL, "http://") &amp;&amp; !strings.HasPrefix(req.URL, "https://") </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid URL format (must start with http:// or https://)"))
                        return
                }</span>

                // Check if article already exists
                <span class="cov0" title="0">exists, err := db.ArticleExistsByURL(dbConn, req.URL)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, WrapError(err, ErrInternal, "Failed to check for existing article"))
                        return
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        RespondError(c, ErrDuplicateURL)
                        return
                }</span>

                // Parse pub_date
                <span class="cov0" title="0">pubDate, err := time.Parse(time.RFC3339, req.PubDate)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid pub_date format (expected RFC3339)"))
                        return
                }</span>

                <span class="cov0" title="0">zero := 0.0
                llmSource := "llm"
                article := &amp;db.Article{
                        Source:         req.Source,
                        PubDate:        pubDate,
                        URL:            req.URL,
                        Title:          req.Title,
                        Content:        req.Content,
                        CreatedAt:      time.Now(),
                        CompositeScore: &amp;zero,
                        Confidence:     &amp;zero,
                        ScoreSource:    &amp;llmSource,
                }

                id, err := db.InsertArticle(dbConn, article)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, db.ErrDuplicateURL) </span><span class="cov0" title="0">{
                                RespondError(c, ErrDuplicateURL)
                                return
                        }</span>
                        <span class="cov0" title="0">RespondError(c, WrapError(err, ErrInternal, "Failed to create article"))
                        return</span>
                }

                // Fetch the full article object after creation
                <span class="cov0" title="0">createdArticle, err := db.FetchArticleByID(dbConn, id)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, WrapError(err, ErrInternal, "Failed to fetch created article"))
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{
                        "success": true,
                        "data":    articleToPostmanSchema(createdArticle),
                })</span>
        }
}

// Utility function for handling article array results
type ArticleResult struct {
        Article  *db.Article            `json:"article"`
        Scores   []db.LLMScore          `json:"scores"`
        Metadata map[string]interface{} `json:"metadata"`
}

// handleArticleBatch processes a batch of articles
func handleArticleBatch(dbConn *sqlx.DB, articles []db.Article) ([]*ArticleResult, error) <span class="cov0" title="0">{
        results := make([]*ArticleResult, 0, len(articles))
        // ...existing code...
        return results, nil
}</span>

// getArticlesHandler handles GET /articles
// @Summary Get articles
// @Description Fetches a list of articles with optional filters
// @Tags Articles
// @Accept json
// @Produce json
// @Param source query string false "Filter by source (e.g., CNN, Fox)"
// @Param leaning query string false "Filter by political leaning"
// @Param limit query int false "Maximum number of articles to return" default(20) minimum(1) maximum(100)
// @Param offset query int false "Number of articles to skip" default(0) minimum(0)
// @Success 200 {object} StandardResponse{data=[]db.Article} "Success"
// @Failure 400 {object} ErrorResponse "Invalid parameters"
// @Failure 500 {object} ErrorResponse "Server error"
// @Router /articles [get]
func getArticlesHandler(dbConn *sqlx.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                source := c.Query("source")
                leaning := c.Query("leaning")
                limitStr := c.DefaultQuery("limit", "20")
                offsetStr := c.DefaultQuery("offset", "0")

                limit, err := strconv.Atoi(limitStr)
                if err != nil || limit &lt; 1 || limit &gt; 100 </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] getArticlesHandler: invalid limit parameter: %v", err)
                        RespondError(c, NewAppError(ErrValidation, "Invalid 'limit' parameter"))
                        return
                }</span>
                <span class="cov0" title="0">offset, err := strconv.Atoi(offsetStr)
                if err != nil || offset &lt; 0 </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] getArticlesHandler: invalid offset parameter: %v", err)
                        RespondError(c, NewAppError(ErrValidation, "Invalid 'offset' parameter"))
                        return
                }</span>

                <span class="cov0" title="0">log.Printf("[INFO] getArticlesHandler: Fetching articles (source=%s, leaning=%s, limit=%d, offset=%d)", source, leaning, limit, offset)
                articles, err := db.FetchArticles(dbConn, source, leaning, limit, offset)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] getArticlesHandler: Database error fetching articles: %+v", err)
                        RespondError(c, WrapError(err, ErrInternal, "Failed to fetch articles"))
                        return
                }</span>

                // Enhance articles with composite scores and confidence
                <span class="cov0" title="0">for i := range articles </span><span class="cov0" title="0">{
                        scores, _ := db.FetchLLMScores(dbConn, articles[i].ID)
                        if len(scores) &gt; 0 </span><span class="cov0" title="0">{
                                var weightedSum, sumWeights float64
                                for _, s := range scores </span><span class="cov0" title="0">{
                                        var meta struct {
                                                Confidence float64 `json:"confidence"`
                                        }
                                        _ = json.Unmarshal([]byte(s.Metadata), &amp;meta)
                                        weightedSum += s.Score * meta.Confidence
                                        sumWeights += meta.Confidence
                                }</span>
                                <span class="cov0" title="0">if sumWeights &gt; 0 </span><span class="cov0" title="0">{
                                        compositeScore := weightedSum / sumWeights
                                        avgConfidence := sumWeights / float64(len(scores))
                                        articles[i].CompositeScore = &amp;compositeScore
                                        articles[i].Confidence = &amp;avgConfidence
                                }</span>
                        }
                }

                // Map to Postman schema
                <span class="cov0" title="0">var out []map[string]interface{}
                for i := range articles </span><span class="cov0" title="0">{
                        out = append(out, articleToPostmanSchema(&amp;articles[i]))
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "data":    out,
                })
                LogPerformance("getArticlesHandler", start)</span>
        }
}

// getArticleByIDHandler handles GET /articles/:id
// @Summary Get article by ID
// @Description Fetches a specific article by its ID with scores and metadata
// @Tags Articles
// @Accept json
// @Produce json
// @Param id path int true "Article ID" minimum(1)
// @Success 200 {object} StandardResponse "Success with article details"
// @Failure 400 {object} ErrorResponse "Invalid article ID"
// @Failure 404 {object} ErrorResponse "Article not found"
// @Failure 500 {object} ErrorResponse "Server error"
// @Router /articles/{id} [get]
func getArticleByIDHandler(dbConn *sqlx.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                idStr := c.Param("id")

                id, err := strconv.ParseInt(idStr, 10, 64)
                if err != nil || id &lt; 1 </span><span class="cov0" title="0">{
                        RespondError(c, ErrInvalidArticleID)
                        return
                }</span>

                // Caching
                <span class="cov0" title="0">cacheKey := "article:" + idStr
                articlesCacheLock.RLock()
                if cached, found := articlesCache.Get(cacheKey); found </span><span class="cov0" title="0">{
                        articlesCacheLock.RUnlock()
                        RespondSuccess(c, cached)
                        LogPerformance("getArticleByIDHandler (cache hit)", start)
                        return
                }</span>
                <span class="cov0" title="0">articlesCacheLock.RUnlock()

                article, err := db.FetchArticleByID(dbConn, id)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, db.ErrArticleNotFound) </span><span class="cov0" title="0">{
                                RespondError(c, ErrArticleNotFound)
                                return
                        }</span>
                        <span class="cov0" title="0">RespondError(c, WrapError(err, ErrInternal, "Failed to fetch article"))
                        LogError("getArticleByIDHandler: fetch article", err)
                        return</span>
                }

                // Use the same schema as other endpoints
                <span class="cov0" title="0">result := articleToPostmanSchema(article)

                // Cache the result for 30 seconds
                articlesCacheLock.Lock()
                articlesCache.Set(cacheKey, result, 30*time.Second)
                articlesCacheLock.Unlock()

                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "data":    result,
                })
                LogPerformance("getArticleByIDHandler", start)</span>
        }
}

// @Summary Trigger RSS feed refresh
// @Description Initiates a manual RSS feed refresh job
// @Tags Feeds
// @Success 200 {object} StandardResponse "Refresh started"
// @Router /api/refresh [post]
func refreshHandler(rssCollector *rss.Collector) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                go rssCollector.ManualRefresh()
                RespondSuccess(c, map[string]string{"status": "refresh started"})
                LogPerformance("refreshHandler", start)
        }</span>
}

// Refactored reanalyzeHandler to use ScoreManager for scoring, storage, and progress
// @Summary Reanalyze article
// @Description Initiates a reanalysis of an article's political bias or directly updates the score
// @Tags Analysis
// @Accept json
// @Produce json
// @Param id path int true "Article ID" minimum(1)
// @Param request body ManualScoreRequest false "Optional score to set directly"
// @Success 200 {object} StandardResponse "Success - reanalysis queued or score updated"
// @Failure 400 {object} ErrorResponse "Invalid article ID or score"
// @Failure 404 {object} ErrorResponse "Article not found"
// @Failure 429 {object} ErrorResponse "Rate limit exceeded"
// @Failure 500 {object} ErrorResponse "Internal server error or LLM service unavailable"
// @Router /llm/reanalyze/{id} [post]
func reanalyzeHandler(llmClient *llm.LLMClient, dbConn *sqlx.DB, scoreManager *llm.ScoreManager) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                idStr := c.Param("id")
                id, err := strconv.Atoi(idStr)
                if err != nil || id &lt; 1 </span><span class="cov0" title="0">{
                        RespondError(c, ErrInvalidArticleID)
                        return
                }</span>
                <span class="cov0" title="0">articleID := int64(id)
                log.Printf("[POST /api/llm/reanalyze] ArticleID=%d", articleID)

                // Check if article exists
                article, err := db.FetchArticleByID(dbConn, articleID)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, db.ErrArticleNotFound) </span><span class="cov0" title="0">{
                                RespondError(c, ErrArticleNotFound)
                                return
                        }</span>
                        <span class="cov0" title="0">RespondError(c, WrapError(err, ErrInternal, "Failed to fetch article"))
                        return</span>
                }

                // Parse raw JSON body
                <span class="cov0" title="0">var raw map[string]interface{}
                if err := c.ShouldBindJSON(&amp;raw); err != nil </span><span class="cov0" title="0">{
                        RespondError(c, ErrInvalidPayload)
                        return
                }</span>

                // Direct score update path - check if "score" field exists
                <span class="cov0" title="0">if scoreRaw, hasScore := raw["score"]; hasScore </span><span class="cov0" title="0">{
                        var scoreFloat float64
                        switch s := scoreRaw.(type) </span>{
                        case float64:<span class="cov0" title="0">
                                scoreFloat = s</span>
                        case float32:<span class="cov0" title="0">
                                scoreFloat = float64(s)</span>
                        case int:<span class="cov0" title="0">
                                scoreFloat = float64(s)</span>
                        case int64:<span class="cov0" title="0">
                                scoreFloat = float64(s)</span>
                        case string:<span class="cov0" title="0">
                                var parseErr error
                                scoreFloat, parseErr = strconv.ParseFloat(s, 64)
                                if parseErr != nil </span><span class="cov0" title="0">{
                                        RespondError(c, NewAppError(ErrValidation, "Invalid score value"))
                                        LogError("reanalyzeHandler: invalid score format", parseErr)
                                        return
                                }</span>
                        default:<span class="cov0" title="0">
                                RespondError(c, NewAppError(ErrValidation, "Invalid score value"))
                                LogError("reanalyzeHandler: invalid score value", nil)
                                return</span>
                        }

                        <span class="cov0" title="0">if scoreFloat &lt; -1.0 || scoreFloat &gt; 1.0 </span><span class="cov0" title="0">{
                                RespondError(c, NewAppError(ErrValidation, "Score must be between -1.0 and 1.0"))
                                LogError("reanalyzeHandler: invalid score value", nil)
                                return
                        }</span>

                        <span class="cov0" title="0">confidence := 1.0 // Use maximum confidence for direct score updates
                        err = db.UpdateArticleScoreLLM(dbConn, articleID, scoreFloat, confidence)
                        if err != nil </span><span class="cov0" title="0">{
                                RespondError(c, NewAppError(ErrInternal, "Failed to update article score"))
                                LogError("reanalyzeHandler: failed to update article score", err)
                                return
                        }</span>

                        // Invalidate cache using ScoreManager
                        <span class="cov0" title="0">if scoreManager != nil </span><span class="cov0" title="0">{
                                scoreManager.InvalidateScoreCache(articleID)
                        }</span>

                        <span class="cov0" title="0">RespondSuccess(c, map[string]interface{}{
                                "status":     "score updated",
                                "article_id": articleID,
                                "score":      scoreFloat,
                        })
                        return</span>
                }

                <span class="cov0" title="0">cfg, cfgErr := llm.LoadCompositeScoreConfig()
                if cfgErr != nil || len(cfg.Models) == 0 </span><span class="cov0" title="0">{
                        RespondError(c, ErrLLMUnavailable)
                        return
                }</span>

                <span class="cov0" title="0">modelName := cfg.Models[0].ModelName
                originalTimeout := 10 * time.Second
                llmClient.SetHTTPLLMTimeout(2 * time.Second)
                _, healthErr := llmClient.ScoreWithModel(article, modelName)
                llmClient.SetHTTPLLMTimeout(originalTimeout)

                if healthErr != nil </span><span class="cov0" title="0">{
                        if errors.Is(healthErr, llm.ErrBothLLMKeysRateLimited) </span><span class="cov0" title="0">{
                                RespondError(c, ErrRateLimited)
                                return
                        }</span>
                        <span class="cov0" title="0">if errors.Is(healthErr, llm.ErrLLMServiceUnavailable) </span><span class="cov0" title="0">{
                                RespondError(c, ErrLLMUnavailable)
                                return
                        }</span>
                        <span class="cov0" title="0">RespondError(c, WrapError(healthErr, ErrLLMService, "LLM provider error"))
                        return</span>
                }

                // Initial progress state
                <span class="cov0" title="0">if scoreManager != nil </span><span class="cov0" title="0">{
                        scoreManager.SetProgress(articleID, &amp;models.ProgressState{
                                Step:        "Starting",
                                Message:     "Scoring job queued",
                                Percent:     0,
                                Status:      "InProgress",
                                LastUpdated: time.Now().Unix(),
                        })
                }</span>

                <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Internal panic: %v", r)
                                        setProgress(articleID, &amp;models.ProgressState{
                                                Step:        "Error",
                                                Message:     "Internal error occurred",
                                                Percent:     0,
                                                Status:      "Error",
                                                Error:       errMsg,
                                                LastUpdated: time.Now().Unix(),
                                        })
                                        log.Printf("[Goroutine Panic] ArticleID=%d: %s", articleID, errMsg)
                                }</span>
                        }()

                        <span class="cov0" title="0">totalSteps := len(cfg.Models) + 3
                        stepNum := 1

                        if scoreManager != nil </span><span class="cov0" title="0">{
                                scoreManager.SetProgress(articleID, &amp;models.ProgressState{
                                        Step:        "Preparing",
                                        Message:     "Deleting old scores",
                                        Percent:     percent(stepNum, totalSteps),
                                        Status:      "InProgress",
                                        LastUpdated: time.Now().Unix(),
                                })
                        }</span>
                        <span class="cov0" title="0">if err := llmClient.DeleteScores(articleID); err != nil </span><span class="cov0" title="0">{
                                errMsg := fmt.Sprintf("Failed to delete old scores: %v", err)
                                setProgress(articleID, &amp;models.ProgressState{
                                        Step:        "Error",
                                        Message:     errMsg,
                                        Percent:     percent(stepNum, totalSteps),
                                        Status:      "Error",
                                        Error:       errMsg,
                                        LastUpdated: time.Now().Unix(),
                                })
                                log.Printf("[SetProgress] ArticleID=%d: %s", articleID, errMsg)
                                return
                        }</span>
                        <span class="cov0" title="0">stepNum++

                        for _, m := range cfg.Models </span><span class="cov0" title="0">{
                                label := fmt.Sprintf("Scoring with %s", m.ModelName)
                                if scoreManager != nil </span><span class="cov0" title="0">{
                                        scoreManager.SetProgress(articleID, &amp;models.ProgressState{
                                                Step:        label,
                                                Message:     label,
                                                Percent:     percent(stepNum, totalSteps),
                                                Status:      "InProgress",
                                                LastUpdated: time.Now().Unix(),
                                        })
                                }</span>
                                <span class="cov0" title="0">_, scoreErr := llmClient.ScoreWithModel(article, m.ModelName)
                                if scoreErr != nil </span><span class="cov0" title="0">{
                                        userMsg := fmt.Sprintf("Error scoring with %s", m.ModelName)
                                        if errors.Is(scoreErr, llm.ErrBothLLMKeysRateLimited) </span><span class="cov0" title="0">{
                                                userMsg = "Rate limit exceeded"
                                        }</span>
                                        <span class="cov0" title="0">setProgress(articleID, &amp;models.ProgressState{
                                                Step:        "Error",
                                                Message:     userMsg,
                                                Percent:     percent(stepNum, totalSteps),
                                                Status:      "Error",
                                                Error:       scoreErr.Error(),
                                                LastUpdated: time.Now().Unix(),
                                        })
                                        log.Printf("[SetProgress] ArticleID=%d: %s", articleID, userMsg)
                                        return</span>
                                }
                                <span class="cov0" title="0">stepNum++</span>
                        }

                        <span class="cov0" title="0">if scoreManager != nil </span><span class="cov0" title="0">{
                                scoreManager.SetProgress(articleID, &amp;models.ProgressState{
                                        Step:        "Calculating",
                                        Message:     "Computing final score",
                                        Percent:     percent(stepNum, totalSteps),
                                        Status:      "InProgress",
                                        LastUpdated: time.Now().Unix(),
                                        FinalScore:  nil,
                                })
                        }</span>
                        <span class="cov0" title="0">scores, fetchErr := llmClient.FetchScores(articleID)
                        if fetchErr != nil </span><span class="cov0" title="0">{
                                errMsg := fmt.Sprintf("Failed to fetch scores: %v", fetchErr)
                                setProgress(articleID, &amp;models.ProgressState{
                                        Step:        "Error",
                                        Message:     errMsg,
                                        Percent:     percent(stepNum, totalSteps),
                                        Status:      "Error",
                                        Error:       errMsg,
                                        LastUpdated: time.Now().Unix(),
                                })
                                log.Printf("[SetProgress] ArticleID=%d: %s", articleID, errMsg)
                                return
                        }</span>
                        <span class="cov0" title="0">stepNum++

                        if scoreManager != nil </span><span class="cov0" title="0">{
                                scoreManager.SetProgress(articleID, &amp;models.ProgressState{
                                        Step:        "Storing",
                                        Message:     "Saving results",
                                        Percent:     percent(stepNum, totalSteps),
                                        Status:      "InProgress",
                                        LastUpdated: time.Now().Unix(),
                                })
                        }</span>
                        <span class="cov0" title="0">finalScore, confidence, storeErr := scoreManager.UpdateArticleScore(articleID, scores, cfg)
                        if storeErr != nil </span><span class="cov0" title="0">{
                                errMsg := fmt.Sprintf("Failed to store score: %v", storeErr)
                                setProgress(articleID, &amp;models.ProgressState{
                                        Step:        "Error",
                                        Message:     errMsg,
                                        Percent:     percent(stepNum, totalSteps),
                                        Status:      "Error",
                                        Error:       errMsg,
                                        LastUpdated: time.Now().Unix(),
                                })
                                log.Printf("[SetProgress] ArticleID=%d: %s", articleID, errMsg)
                                return
                        }</span>

                        // Final success state with composite score
                        <span class="cov0" title="0">confidencePercent := int(confidence * 100)
                        message := fmt.Sprintf("Scoring complete (confidence: %d%%)", confidencePercent)
                        setProgress(articleID, &amp;models.ProgressState{
                                Step:        "Complete",
                                Message:     message,
                                Percent:     100,
                                Status:      "Success",
                                FinalScore:  &amp;finalScore,
                                LastUpdated: time.Now().Unix(),
                        })
                        log.Printf("[SetProgress] ArticleID=%d: %s", articleID, message)</span>
                }()

                <span class="cov0" title="0">RespondSuccess(c, gin.H{
                        "status":     "reanalyze queued",
                        "article_id": articleID,
                })</span>
        }
}

// @Summary Score progress SSE stream
// @Description Server-Sent Events endpoint streaming scoring progress for an article
// @Tags Analysis
// @Param id path int true "Article ID" minimum(1)
// @Success 200 {string} string "event-stream"
// @Router /api/llm/score-progress/{id} [get]
func scoreProgressSSEHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                idStr := c.Param("id")
                id, err := strconv.Atoi(idStr)
                if err != nil || id &lt; 1 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid article ID"})
                        return
                }</span>
                <span class="cov0" title="0">articleID := int64(id)
                log.Printf("[SSE GET /api/llm/score-progress] ArticleID=%d", articleID)

                c.Writer.Header().Set("Content-Type", "text/event-stream")
                c.Writer.Header().Set("Cache-Control", "no-cache")
                c.Writer.Header().Set("Connection", "keep-alive")
                c.Writer.Flush()

                lastProgress := ""
                ticker := time.NewTicker(500 * time.Millisecond)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-c.Request.Context().Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                progress := getProgress(articleID)
                                if progress == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Always send updates when status changes or on final states
                                <span class="cov0" title="0">if data, err := json.Marshal(progress); err == nil </span><span class="cov0" title="0">{
                                        currentProgress := string(data)
                                        if currentProgress != lastProgress </span><span class="cov0" title="0">{
                                                fmt.Fprintf(c.Writer, "data: %s\n\n", data)
                                                c.Writer.Flush()
                                                lastProgress = currentProgress

                                                // Close connection on final states
                                                if progress.Status == "Success" || progress.Status == "Error" </span><span class="cov0" title="0">{
                                                        return
                                                }</span>
                                        }
                                }
                        }
                }
        }
}

// Helper to calculate percent complete
func percent(step, total int) int <span class="cov0" title="0">{
        if total == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">p := (step * 100) / total
        if p &gt; 100 </span><span class="cov0" title="0">{
                return 100
        }</span>
        <span class="cov0" title="0">return p</span>
}

// @Summary Get feed health status
// @Description Returns the health of configured RSS feed sources
// @Tags Feeds
// @Success 200 {object} map[string]bool
// @Router /api/feeds/healthz [get]
func feedHealthHandler(rssCollector *rss.Collector) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                status := rssCollector.CheckFeedHealth()
                c.JSON(200, status)
        }</span>
}

// @Summary Get article summary
// @Description Retrieves the text summary for an article
// @Tags Summary
// @Param id path int true "Article ID" minimum(1)
// @Success 200 {object} StandardResponse
// @Failure 404 {object} ErrorResponse "Summary not available"
// @Router /api/articles/{id}/summary [get]
func summaryHandler(dbConn *sqlx.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                idStr := c.Param("id")

                id, err := strconv.ParseInt(idStr, 10, 64)
                if err != nil || id &lt; 1 </span><span class="cov0" title="0">{
                        RespondError(c, ErrInvalidArticleID)
                        return
                }</span>

                // Caching
                <span class="cov0" title="0">cacheKey := "summary:" + idStr
                articlesCacheLock.RLock()
                if cached, found := articlesCache.Get(cacheKey); found </span><span class="cov0" title="0">{
                        articlesCacheLock.RUnlock()
                        RespondSuccess(c, cached)
                        LogPerformance("summaryHandler (cache hit)", start)
                        return
                }</span>
                <span class="cov0" title="0">articlesCacheLock.RUnlock()

                // Verify article exists
                _, err = db.FetchArticleByID(dbConn, id)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, db.ErrArticleNotFound) </span><span class="cov0" title="0">{
                                RespondError(c, ErrArticleNotFound)
                                return
                        }</span>
                        <span class="cov0" title="0">RespondError(c, WrapError(err, ErrInternal, "Failed to fetch article"))
                        return</span>
                }

                <span class="cov0" title="0">scores, err := db.FetchLLMScores(dbConn, id)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, WrapError(err, ErrInternal, "Failed to fetch article summary"))
                        return
                }</span>

                <span class="cov0" title="0">for _, score := range scores </span><span class="cov0" title="0">{
                        if score.Model == "summarizer" </span><span class="cov0" title="0">{
                                result := map[string]interface{}{
                                        "summary":    score.Metadata,
                                        "created_at": score.CreatedAt,
                                }
                                articlesCacheLock.Lock()
                                articlesCache.Set(cacheKey, result, 30*time.Second)
                                articlesCacheLock.Unlock()

                                RespondSuccess(c, result)
                                LogPerformance("summaryHandler", start)
                                return
                        }</span>
                }

                <span class="cov0" title="0">RespondError(c, NewAppError(ErrNotFound, "Article summary not available"))
                LogPerformance("summaryHandler", start)</span>
        }
}

func parseArticleID(c *gin.Context) (int64, bool) <span class="cov0" title="0">{
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": errInvalidArticleID})
                return 0, false
        }</span>
        <span class="cov0" title="0">return int64(id), true</span>
}

func filterAndTransformScores(scores []db.LLMScore, min, max float64) []map[string]interface{} <span class="cov0" title="0">{
        results := make([]map[string]interface{}, 0, len(scores))
        for _, score := range scores </span><span class="cov0" title="0">{
                if score.Model != "ensemble" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">var meta map[string]interface{}
                if err := json.Unmarshal([]byte(score.Metadata), &amp;meta); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">agg, _ := meta["aggregation"].(map[string]interface{})
                weightedMean, _ := agg["weighted_mean"].(float64)
                if weightedMean &lt; min || weightedMean &gt; max </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">result := map[string]interface{}{
                        "score":      weightedMean,
                        "metadata":   meta,
                        "created_at": score.CreatedAt,
                }
                results = append(results, result)</span>
        }
        <span class="cov0" title="0">return results</span>
}

func sortResults(results []map[string]interface{}, order string) <span class="cov0" title="0">{
        if order == "asc" </span><span class="cov0" title="0">{
                sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                        return results[i]["score"].(float64) &lt; results[j]["score"].(float64)
                }</span>)
        } else<span class="cov0" title="0"> {
                sort.Slice(results, func(i, j int) bool </span><span class="cov0" title="0">{
                        return results[i]["score"].(float64) &gt; results[j]["score"].(float64)
                }</span>)
        }
}

// biasHandler returns article bias scores and composite score.
// @Summary Get article bias analysis
// @Description Retrieves the political bias score and individual model results for an article
// @Tags Analysis
// @Accept json
// @Produce json
// @Param id path int true "Article ID" minimum(1)
// @Param min_score query number false "Minimum score filter" default(-1) minimum(-1) maximum(1)
// @Param max_score query number false "Maximum score filter" default(1) minimum(-1) maximum(1)
// @Param sort query string false "Sort order (asc or desc)" Enums(asc, desc) default(desc)
// @Success 200 {object} StandardResponse{data=ScoreResponse} "Success"
// @Failure 400 {object} ErrorResponse "Invalid parameters"
// @Failure 404 {object} ErrorResponse "Article not found"
// @Failure 500 {object} ErrorResponse "Server error"
// @Router /articles/{id}/bias [get]
// If no valid LLM scores are available, the API responds with:
//   - "composite_score": null
//   - "status": "scoring_unavailable"
//
// instead of defaulting to zero values.
// This indicates that scoring data is currently unavailable.
func biasHandler(dbConn *sqlx.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                idStr := c.Param("id")
                articleID, err := strconv.ParseInt(idStr, 10, 64)
                if err != nil || articleID &lt; 1 </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid article ID"))
                        LogError("biasHandler: invalid id", err)
                        return
                }</span>

                <span class="cov0" title="0">minScore, err := strconv.ParseFloat(c.DefaultQuery("min_score", "-1"), 64)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid min_score"))
                        LogError("biasHandler: invalid min_score", err)
                        return
                }</span>
                <span class="cov0" title="0">maxScore, err := strconv.ParseFloat(c.DefaultQuery("max_score", "1"), 64)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid max_score"))
                        LogError("biasHandler: invalid max_score", err)
                        return
                }</span>
                <span class="cov0" title="0">sortOrder := c.DefaultQuery("sort", "desc")
                if sortOrder != "asc" &amp;&amp; sortOrder != "desc" </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid sort order"))
                        LogError("biasHandler: invalid sort order", nil)
                        return
                }</span>

                // Caching
                <span class="cov0" title="0">cacheKey := "bias:" + idStr + ":" + c.DefaultQuery("min_score", "-1") + ":" + c.DefaultQuery("max_score", "1") + ":" + sortOrder
                articlesCacheLock.RLock()
                if cached, found := articlesCache.Get(cacheKey); found </span><span class="cov0" title="0">{
                        articlesCacheLock.RUnlock()
                        RespondSuccess(c, cached)
                        LogPerformance("biasHandler (cache hit)", start)
                        return
                }</span>
                <span class="cov0" title="0">articlesCacheLock.RUnlock()

                scores, err := db.FetchLLMScores(dbConn, articleID)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrInternal, "Failed to fetch bias data"))
                        LogError("biasHandler: fetch scores", err)
                        return
                }</span>

                <span class="cov0" title="0">var latestEnsembleScore *db.LLMScore
                individualResults := make([]map[string]interface{}, 0)

                // Find the latest ensemble score and gather individual scores
                for i := range scores </span><span class="cov0" title="0">{
                        score := scores[i] // Create a copy to avoid loop variable issues if needed later

                        if score.Model == "ensemble" </span><span class="cov0" title="0">{
                                if latestEnsembleScore == nil || score.CreatedAt.After(latestEnsembleScore.CreatedAt) </span><span class="cov0" title="0">{
                                        latestEnsembleScore = &amp;score // Store pointer to the score
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Parse metadata for individual scores
                                var meta struct {
                                        Confidence  *float64 `json:"Confidence"`  // Use pointer for optional field
                                        Explanation *string  `json:"Explanation"` // Use pointer for optional field
                                }
                                // Default values
                                confidence := 0.0
                                explanation := ""

                                if score.Metadata != "" </span><span class="cov0" title="0">{
                                        if err := json.Unmarshal([]byte(score.Metadata), &amp;meta); err == nil </span><span class="cov0" title="0">{
                                                if meta.Confidence != nil </span><span class="cov0" title="0">{
                                                        confidence = *meta.Confidence
                                                }</span>
                                                <span class="cov0" title="0">if meta.Explanation != nil </span><span class="cov0" title="0">{
                                                        explanation = *meta.Explanation
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                log.Printf("WARN: biasHandler: Failed to unmarshal metadata for score ID %d, model %s: %v", score.ID, score.Model, err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        log.Printf("WARN: biasHandler: Empty metadata for score ID %d, model %s", score.ID, score.Model)
                                }</span>

                                // Add to results, applying score filtering
                                <span class="cov0" title="0">if score.Score &gt;= minScore &amp;&amp; score.Score &lt;= maxScore </span><span class="cov0" title="0">{
                                        individualResults = append(individualResults, map[string]interface{}{
                                                "model":       score.Model,
                                                "score":       score.Score,
                                                "confidence":  confidence,
                                                "explanation": explanation,
                                                "created_at":  score.CreatedAt, // Include timestamp if needed by frontend/sorting
                                        })
                                }</span>
                        }
                }

                // Sort individual results
                <span class="cov0" title="0">sort.SliceStable(individualResults, func(i, j int) bool </span><span class="cov0" title="0">{
                        scoreI := individualResults[i]["score"].(float64)
                        scoreJ := individualResults[j]["score"].(float64)
                        if sortOrder == "asc" </span><span class="cov0" title="0">{
                                return scoreI &lt; scoreJ
                        }</span>
                        <span class="cov0" title="0">return scoreI &gt; scoreJ</span> // desc
                })

                <span class="cov0" title="0">var compositeScoreValue interface{} = nil // Default to null
                status := ""
                if latestEnsembleScore != nil </span><span class="cov0" title="0">{
                        compositeScoreValue = latestEnsembleScore.Score
                }</span> else<span class="cov0" title="0"> {
                        // If no ensemble score exists, explicitly set status
                        status = "scoring_unavailable"
                }</span>

                <span class="cov0" title="0">resp := map[string]interface{}{
                        "composite_score": compositeScoreValue,
                        "results":         individualResults,
                }
                // Add status only if it's set (i.e., no ensemble score found)
                if status != "" </span><span class="cov0" title="0">{
                        resp["status"] = status
                }</span>

                // Cache the result for 30 seconds
                <span class="cov0" title="0">articlesCacheLock.Lock()
                articlesCache.Set(cacheKey, resp, 30*time.Second)
                articlesCacheLock.Unlock()

                // DEBUG: Log the response being sent, especially for article 1646
                if articleID == 1646 </span><span class="cov0" title="0">{
                        log.Printf("[biasHandler DEBUG 1646] Sending response: %+v", resp)
                }</span>

                <span class="cov0" title="0">RespondSuccess(c, resp)
                LogPerformance("biasHandler", start)</span>
        }
}

// @Summary Get ensemble scoring details
// @Description Retrieves individual model results and aggregation for an article's ensemble score
// @Tags Analysis
// @Param id path int true "Article ID" minimum(1)
// @Success 200 {object} StandardResponse
// @Failure 404 {object} ErrorResponse "Ensemble data not found"
// @Router /api/articles/{id}/ensemble [get]
func ensembleDetailsHandler(dbConn *sqlx.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                idStr := c.Param("id")
                id, err := strconv.Atoi(idStr)
                if err != nil || id &lt; 1 </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid article ID"))
                        LogError("ensembleDetailsHandler: invalid id", err)
                        return
                }</span>

                // Skip cache if _t query param exists (cache busting)
                <span class="cov0" title="0">if _, skipCache := c.GetQuery("_t"); skipCache </span><span class="cov0" title="0">{
                        log.Printf("[ensembleDetailsHandler] Cache busting requested for article %d", id)
                        scores, err := db.FetchLLMScores(dbConn, int64(id))
                        if err != nil </span><span class="cov0" title="0">{
                                RespondError(c, NewAppError(ErrInternal, "Failed to fetch ensemble data"))
                                LogError("ensembleDetailsHandler: fetch scores", err)
                                return
                        }</span>
                        <span class="cov0" title="0">details := processEnsembleScores(scores)
                        if len(details) == 0 </span><span class="cov0" title="0">{
                                RespondError(c, NewAppError(ErrNotFound, "Ensemble data not found"))
                                return
                        }</span>
                        <span class="cov0" title="0">RespondSuccess(c, gin.H{"scores": details})
                        LogPerformance("ensembleDetailsHandler (cache bust)", start)
                        return</span>
                }

                // Regular caching logic
                <span class="cov0" title="0">cacheKey := "ensemble:" + idStr
                articlesCacheLock.RLock()
                if cachedRaw, found := articlesCache.Get(cacheKey); found </span><span class="cov0" title="0">{
                        articlesCacheLock.RUnlock()
                        c.JSON(http.StatusOK, gin.H{
                                "success": true,
                                "scores":  cachedRaw,
                        })
                        LogPerformance("ensembleDetailsHandler (cache hit)", start)
                        return
                }</span>
                <span class="cov0" title="0">articlesCacheLock.RUnlock()

                scores, err := db.FetchLLMScores(dbConn, int64(id))
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrInternal, "Failed to fetch ensemble data"))
                        LogError("ensembleDetailsHandler: fetch scores", err)
                        return
                }</span>

                <span class="cov0" title="0">details := processEnsembleScores(scores)
                if len(details) == 0 </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrNotFound, "Ensemble data not found"))
                        LogPerformance("ensembleDetailsHandler", start)
                        return
                }</span>

                <span class="cov0" title="0">articlesCacheLock.Lock()
                articlesCache.Set(cacheKey, details, 30*time.Second)
                articlesCacheLock.Unlock()

                c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "scores":  details,
                })
                LogPerformance("ensembleDetailsHandler", start)</span>
        }
}

// Helper function to process ensemble scores
func processEnsembleScores(scores []db.LLMScore) []map[string]interface{} <span class="cov0" title="0">{
        details := make([]map[string]interface{}, 0)
        for _, score := range scores </span><span class="cov0" title="0">{
                if score.Model != "ensemble" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">var meta map[string]interface{}
                if err := json.Unmarshal([]byte(score.Metadata), &amp;meta); err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ensembleDetailsHandler] Error unmarshalling metadata for score ID %d: %v", score.ID, err)
                        details = append(details, map[string]interface{}{
                                "score":       score.Score,
                                "sub_results": []interface{}{},
                                "aggregation": map[string]interface{}{},
                                "created_at":  score.CreatedAt,
                                "error":       "Metadata parsing failed",
                        })
                        continue</span>
                }

                <span class="cov0" title="0">subResults, ok1 := meta["sub_results"].([]interface{})
                if !ok1 </span><span class="cov0" title="0">{
                        subResults = []interface{}{}
                }</span>

                <span class="cov0" title="0">aggregation, ok2 := meta["aggregation"].(map[string]interface{})
                if !ok2 </span><span class="cov0" title="0">{
                        aggregation = map[string]interface{}{}
                }</span>

                <span class="cov0" title="0">details = append(details, map[string]interface{}{
                        "score":       score.Score,
                        "sub_results": subResults,
                        "aggregation": aggregation,
                        "created_at":  score.CreatedAt,
                })</span>
        }
        <span class="cov0" title="0">return details</span>
}

// @Summary Submit user feedback
// @Description Submit user feedback on an article's political bias analysis
// @Tags Feedback
// @Accept json
// @Produce json
// @Param request body FeedbackRequest true "Feedback information"
// @Success 200 {object} StandardResponse "Feedback received"
// @Failure 400 {object} ErrorResponse "Invalid request data"
// @Failure 500 {object} ErrorResponse "Server error"
// @Router /feedback [post]
func feedbackHandler(dbConn *sqlx.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()
                var req struct {
                        ArticleID        int64  `json:"article_id" form:"article_id"`
                        UserID           string `json:"user_id" form:"user_id"`
                        FeedbackText     string `json:"feedback_text" form:"feedback_text"`
                        Category         string `json:"category" form:"category"`
                        EnsembleOutputID *int64 `json:"ensemble_output_id" form:"ensemble_output_id"`
                        Source           string `json:"source" form:"source"`
                }

                if err := c.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                        RespondError(c, ErrInvalidPayload)
                        return
                }</span>

                // Validate all required fields
                <span class="cov0" title="0">var missingFields []string
                if req.ArticleID == 0 </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, "article_id")
                }</span>
                <span class="cov0" title="0">if req.FeedbackText == "" </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, "feedback_text")
                }</span>
                <span class="cov0" title="0">if req.UserID == "" </span><span class="cov0" title="0">{
                        missingFields = append(missingFields, "user_id")
                }</span>

                <span class="cov0" title="0">if len(missingFields) &gt; 0 </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation,
                                fmt.Sprintf("Missing required fields: %s", strings.Join(missingFields, ", "))))
                        return
                }</span>

                // Validate Category if provided
                <span class="cov0" title="0">validCategories := map[string]bool{
                        "agree":    true,
                        "disagree": true,
                        "unclear":  true,
                        "other":    true,
                        "":         true, // Allow empty for backward compatibility
                }
                if req.Category != "" &amp;&amp; !validCategories[req.Category] </span><span class="cov0" title="0">{
                        RespondError(c, ErrInvalidCategory)
                        return
                }</span>

                <span class="cov0" title="0">feedback := &amp;db.Feedback{
                        ArticleID:        req.ArticleID,
                        UserID:           req.UserID,
                        FeedbackText:     req.FeedbackText,
                        Category:         req.Category,
                        EnsembleOutputID: req.EnsembleOutputID,
                        Source:           req.Source,
                        CreatedAt:        time.Now(),
                }

                // Insert feedback
                err := db.InsertFeedback(dbConn, feedback)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrInternal, fmt.Sprintf("Failed to store feedback: %v", err)))
                        return
                }</span>

                // Update article confidence based on feedback
                <span class="cov0" title="0">scores, err := db.FetchLLMScores(dbConn, req.ArticleID)
                if err == nil </span><span class="cov0" title="0">{
                        // Calculate new composite score and confidence
                        score, confidence, compErr := llm.ComputeCompositeScoreWithConfidence(scores)
                        if compErr != nil </span><span class="cov0" title="0">{
                                LogError("feedbackHandler: composite score calculation", compErr)
                        }</span> else<span class="cov0" title="0"> {
                                // Adjust confidence based on feedback category
                                if req.Category == "agree" </span><span class="cov0" title="0">{
                                        confidence = math.Min(1.0, confidence+0.1) // Increase confidence on agreement
                                }</span> else<span class="cov0" title="0"> if req.Category == "disagree" </span><span class="cov0" title="0">{
                                        confidence = math.Max(0.0, confidence-0.1) // Decrease confidence on disagreement
                                }</span>

                                // Update article with new confidence
                                <span class="cov0" title="0">err = db.UpdateArticleScore(dbConn, req.ArticleID, score, confidence)
                                if err != nil </span><span class="cov0" title="0">{
                                        // Log error but don't fail the request since feedback was saved
                                        LogError("feedbackHandler: update article confidence", err)
                                }</span>
                        }
                }

                <span class="cov0" title="0">RespondSuccess(c, map[string]string{"status": "feedback received"})
                LogPerformance("feedbackHandler", start)</span>
        }
}

// @Summary Manually set article score
// @Description Updates an article's bias score manually
// @Tags Analysis
// @Param id path int true "Article ID" minimum(1)
// @Param request body ManualScoreRequest true "Score value between -1.0 and 1.0"
// @Success 200 {object} StandardResponse
// @Failure 400 {object} ErrorResponse
// @Router /api/manual-score/{id} [post]
func manualScoreHandler(dbConn *sqlx.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                idStr := c.Param("id")
                id, err := strconv.Atoi(idStr)
                if err != nil || id &lt; 1 </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid article ID"))
                        LogError("manualScoreHandler: invalid id", err)
                        return
                }</span>
                <span class="cov0" title="0">articleID := int64(id)

                // Read raw body for strict validation
                var raw map[string]interface{}
                decoder := json.NewDecoder(c.Request.Body)
                decoder.DisallowUnknownFields()
                if err := decoder.Decode(&amp;raw); err != nil </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid JSON body"))
                        LogError("manualScoreHandler: invalid JSON body", err)
                        return
                }</span>
                // Only "score" is allowed
                <span class="cov0" title="0">if len(raw) != 1 || raw["score"] == nil </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Payload must contain only 'score' field"))
                        LogError("manualScoreHandler: payload missing or has extra fields", nil)
                        return
                }</span>
                // Validate score type and range
                <span class="cov0" title="0">scoreVal, ok := raw["score"].(float64)
                if !ok </span><span class="cov0" title="0">{
                        // Accept integer as well
                        if intVal, okInt := raw["score"].(int); okInt </span><span class="cov0" title="0">{
                                scoreVal = float64(intVal)
                        }</span> else<span class="cov0" title="0"> {
                                RespondError(c, NewAppError(ErrValidation, "'score' must be a number"))
                                LogError("manualScoreHandler: score not a number", nil)
                                return
                        }</span>
                }
                <span class="cov0" title="0">if scoreVal &lt; -1.0 || scoreVal &gt; 1.0 </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Score must be between -1.0 and 1.0"))
                        LogError("manualScoreHandler: score out of range", nil)
                        return
                }</span>

                // Check if article exists
                <span class="cov0" title="0">_, err = db.FetchArticleByID(dbConn, articleID)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, db.ErrArticleNotFound) </span><span class="cov0" title="0">{
                                RespondError(c, NewAppError(ErrNotFound, "Article not found"))
                                return
                        }</span>
                        <span class="cov0" title="0">RespondError(c, NewAppError(ErrInternal, "Failed to fetch article"))
                        LogError("manualScoreHandler: failed to fetch article", err)
                        return</span>
                }

                // Update score in DB
                <span class="cov0" title="0">err = db.UpdateArticleScore(dbConn, articleID, scoreVal, 0)
                if err != nil </span><span class="cov0" title="0">{
                        errMsg := err.Error()
                        if errMsg != "" &amp;&amp; (strings.Contains(errMsg, "constraint failed") ||
                                strings.Contains(errMsg, "UNIQUE constraint failed") ||
                                strings.Contains(errMsg, "CHECK constraint failed") ||
                                strings.Contains(errMsg, "NOT NULL constraint failed") ||
                                strings.Contains(errMsg, "FOREIGN KEY constraint failed") ||
                                strings.Contains(errMsg, "invalid") ||
                                strings.Contains(errMsg, "out of range") ||
                                strings.Contains(errMsg, "data type mismatch")) </span><span class="cov0" title="0">{
                                log.Printf("[manualScoreHandler] Constraint/validation error updating article score: %v", err)
                                RespondError(c, NewAppError(ErrValidation, "Failed to update score due to invalid data or constraint violation"))
                                return
                        }</span>
                        <span class="cov0" title="0">log.Printf("[manualScoreHandler] Unexpected DB error updating article score: %v", err)
                        RespondError(c, NewAppError(ErrInternal, "Failed to update article score"))
                        LogError("manualScoreHandler: failed to update article score", err)
                        return</span>
                }
                <span class="cov0" title="0">log.Printf("[manualScoreHandler] Article score updated successfully: articleID=%d, score=%f", articleID, scoreVal)
                RespondSuccess(c, map[string]interface{}{
                        "status":     "score updated",
                        "article_id": articleID,
                        "score":      scoreVal,
                })</span>
        }
}

// Helper function to convert string to *string
func strPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "sync"
        "time"
)

// Cache implementation
type SimpleCache struct {
        cache map[string]cacheEntry
        mu    sync.RWMutex
}

type cacheEntry struct {
        value      interface{}
        expiration time.Time
}

func NewSimpleCache() *SimpleCache <span class="cov8" title="1">{
        return &amp;SimpleCache{
                cache: make(map[string]cacheEntry),
        }
}</span>

func (c *SimpleCache) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        entry, exists := c.cache[key]
        if !exists </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">if time.Now().After(entry.expiration) </span><span class="cov0" title="0">{
                delete(c.cache, key)
                return nil, false
        }</span>

        <span class="cov0" title="0">return entry.value, true</span>
}

func (c *SimpleCache) Set(key string, value interface{}, ttl time.Duration) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache[key] = cacheEntry{
                value:      value,
                expiration: time.Now().Add(ttl),
        }
}</span>

func (c *SimpleCache) Delete(key string) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        delete(c.cache, key)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "net/http"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
        "github.com/gin-gonic/gin"
        "github.com/jmoiron/sqlx"
)

// debugSchemaHandler returns the database schema for debugging purposes
func debugSchemaHandler(dbConn *sqlx.DB) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Get table names
                var tables []string
                err := dbConn.Select(&amp;tables, "SELECT name FROM sqlite_master WHERE type='table'")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success":       false,
                                "error_message": "Failed to get table names: " + err.Error(),
                        })
                        return
                }</span>

                // Get schema for each table
                <span class="cov0" title="0">schemas := make(map[string][]map[string]interface{})
                for _, table := range tables </span><span class="cov0" title="0">{
                        var columns []map[string]interface{}
                        err := dbConn.Select(&amp;columns, "PRAGMA table_info("+table+")")
                        if err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, gin.H{
                                        "success":       false,
                                        "error_message": "Failed to get schema for table " + table + ": " + err.Error(),
                                })
                                return
                        }</span>
                        <span class="cov0" title="0">schemas[table] = columns</span>
                }

                // Get sample data for feedback table
                <span class="cov0" title="0">var feedbackSamples []db.Feedback
                err = dbConn.Select(&amp;feedbackSamples, "SELECT * FROM feedback LIMIT 5")
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "success":       false,
                                "error_message": "Failed to get feedback samples: " + err.Error(),
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                        "success": true,
                        "data": gin.H{
                                "tables":           tables,
                                "schemas":          schemas,
                                "feedback_samples": feedbackSamples,
                        },
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "github.com/alexandru-savinov/BalancedNewsGo/internal/apperrors"
)

// Pre-defined error codes
const (
        ErrValidation = "validation_error"
        ErrNotFound   = "not_found"
        ErrInternal   = "internal_error"
        ErrRateLimit  = "rate_limit"
        ErrLLMService = "llm_service_error"
        ErrConflict   = "conflict_error"
)

// Error constants for consistent error messages
const (
        errFailedToFetchArticle = "Failed to fetch article"
        errInvalidArticleID     = "Invalid article ID"
        errProgressState        = "[SetProgress] ArticleID=%d: %s"
        // New constants for duplicated strings in tests
        ErrInvalidJSONBody         = "Invalid JSON body"
        ErrPayloadFieldRestriction = "Payload must contain only 'score' field"
        ErrContentTypeHeader       = "Content-Type"
        ErrJSONContentType         = "application/json"
)

// Pre-defined API errors
var (
        ErrInvalidArticleID = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: errInvalidArticleID,
        }

        ErrArticleNotFound = &amp;apperrors.AppError{
                Code:    ErrNotFound,
                Message: "Article not found",
        }

        ErrInvalidPayload = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Invalid request payload",
        }

        ErrMissingFields = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Missing required fields",
        }

        ErrRateLimited = &amp;apperrors.AppError{
                Code:    ErrRateLimit,
                Message: "Rate limit exceeded",
        }

        ErrLLMUnavailable = &amp;apperrors.AppError{
                Code:    ErrLLMService,
                Message: "LLM service unavailable",
        }

        ErrDuplicateURL = &amp;apperrors.AppError{
                Code:    ErrConflict,
                Message: "Article with this URL already exists",
        }

        ErrInvalidScore = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Score must be between -1.0 and 1.0",
        }
)

// Feedback-specific errors
var (
        ErrInvalidCategory = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Invalid feedback category. Must be one of: agree, disagree, unclear, other",
        }

        ErrInvalidFeedback = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Invalid feedback content",
        }

        ErrMissingFeedbackFields = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Missing required feedback fields",
        }

        ErrDuplicateFeedback = &amp;apperrors.AppError{
                Code:    ErrConflict,
                Message: "Duplicate feedback submission for this article",
        }

        ErrFeedbackTooLong = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Feedback text exceeds maximum length",
        }

        ErrInvalidFeedbackSource = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Invalid feedback source identifier",
        }
)

// Bias-specific errors
var (
        ErrInvalidBiasRange = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Invalid bias score range",
        }

        ErrInvalidSortOrder = &amp;apperrors.AppError{
                Code:    ErrValidation,
                Message: "Invalid sort order. Must be 'asc' or 'desc'",
        }

        ErrBiasDataUnavailable = &amp;apperrors.AppError{
                Code:    ErrNotFound,
                Message: "Bias scoring data not available",
        }
)

// NewAppError creates a new application error with the given code and message
func NewAppError(code, message string) *apperrors.AppError <span class="cov8" title="1">{
        return &amp;apperrors.AppError{
                Code:    code,
                Message: message,
        }
}</span>

// WrapError wraps a generic error with context into an AppError
func WrapError(err error, code string, context string) *apperrors.AppError <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">message := context
        if message == "" </span><span class="cov0" title="0">{
                message = err.Error()
        }</span>
        <span class="cov8" title="1">return NewAppError(code, message)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "fmt"
        "strconv"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
        "github.com/alexandru-savinov/BalancedNewsGo/internal/llm"
        "github.com/gin-gonic/gin"
)

// getArticleByIDHandlerWithDB returns a handler function for fetching an article by ID
func getArticleByIDHandlerWithDB(dbOps DBOperations) gin.HandlerFunc <span class="cov8" title="1">{
        return func(c *gin.Context) </span><span class="cov8" title="1">{
                // Get article ID from path parameter
                idStr := c.Param("id")
                id, err := strconv.ParseInt(idStr, 10, 64)
                if err != nil || id &lt; 1 </span><span class="cov0" title="0">{
                        RespondError(c, NewAppError(ErrValidation, "Invalid article ID"))
                        return
                }</span>

                // Fetch article from database
                <span class="cov8" title="1">article, err := dbOps.FetchArticleByID(nil, id)
                if err != nil </span><span class="cov8" title="1">{
                        if err == db.ErrArticleNotFound </span><span class="cov8" title="1">{
                                RespondError(c, NewAppError(ErrNotFound, "Article not found"))
                        }</span> else<span class="cov8" title="1"> {
                                RespondError(c, WrapError(err, ErrInternal, "Failed to fetch article"))
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                // Fetch LLM scores
                <span class="cov8" title="1">scores, err := dbOps.FetchLLMScores(nil, id)
                if err != nil </span><span class="cov0" title="0">{
                        RespondError(c, WrapError(err, ErrInternal, "Failed to fetch LLM scores"))
                        return
                }</span>

                // Use the DefaultScoreCalculator to get composite score and confidence
                <span class="cov8" title="1">calculator := &amp;llm.DefaultScoreCalculator{
                        Config: &amp;llm.CompositeScoreConfig{
                                MinScore:       -1.0,
                                MaxScore:       1.0,
                                DefaultMissing: 0.0,
                        },
                }
                compositeScore, confidence, err := calculator.CalculateScore(scores)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with default values
                        fmt.Printf("Error calculating composite score: %v\n", err)
                        compositeScore = 0.0
                        confidence = 0.0
                }</span>

                // Prepare response with article details and scores
                <span class="cov8" title="1">response := map[string]interface{}{
                        "id":              article.ID,
                        "title":           article.Title,
                        "content":         article.Content,
                        "url":             article.URL,
                        "source":          article.Source,
                        "pub_date":        article.PubDate,
                        "created_at":      article.CreatedAt,
                        "composite_score": compositeScore,
                        "confidence":      confidence,
                }

                // Include individual model scores
                modelScores := make([]map[string]interface{}, 0, len(scores))
                for _, score := range scores </span><span class="cov8" title="1">{
                        if score.Model != "ensemble" </span><span class="cov8" title="1">{
                                modelScores = append(modelScores, map[string]interface{}{
                                        "model":      score.Model,
                                        "score":      score.Score,
                                        "metadata":   score.Metadata,
                                        "created_at": score.CreatedAt,
                                })
                        }</span>
                }
                <span class="cov8" title="1">response["model_scores"] = modelScores

                RespondSuccess(c, response)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "log"
        "net/http"
        "time"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/apperrors"
        "github.com/gin-gonic/gin"
)

// RespondSuccess sends a standardized success response
func RespondSuccess(c *gin.Context, data interface{}) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    data,
        })
}</span>

// RespondError handles application errors with standardized responses
func RespondError(c *gin.Context, err *apperrors.AppError) <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                err = NewAppError(ErrInternal, "Unknown error occurred")
        }</span>

        // Map error codes to HTTP status codes
        <span class="cov8" title="1">status := getHTTPStatus(err.Code)
        c.JSON(status, gin.H{
                "success": false,
                "error": gin.H{
                        "code":    err.Code,
                        "message": err.Message,
                },
        })</span>
}

// LogError logs errors with context, using structured format
func LogError(operation string, err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                if appErr, ok := err.(*apperrors.AppError); ok </span><span class="cov0" title="0">{
                        log.Printf("[ERROR] Operation=%s Code=%s Message=%s",
                                operation, appErr.Code, appErr.Message)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[ERROR] Operation=%s Message=%v",
                                operation, err)
                }</span>
        }
}

// LogPerformance logs performance metrics in a structured format
func LogPerformance(operation string, start time.Time) <span class="cov0" title="0">{
        duration := time.Since(start)
        log.Printf("[PERF] Operation=%s Duration=%v", operation, duration)
}</span>

// getHTTPStatus maps error codes to HTTP status codes
func getHTTPStatus(code string) int <span class="cov8" title="1">{
        switch code </span>{
        case ErrValidation:<span class="cov8" title="1">
                return http.StatusBadRequest</span>
        case ErrNotFound:<span class="cov8" title="1">
                return http.StatusNotFound</span>
        case ErrRateLimit:<span class="cov0" title="0">
                return http.StatusTooManyRequests</span>
        case ErrLLMService:<span class="cov0" title="0">
                return http.StatusServiceUnavailable</span>
        case ErrConflict:<span class="cov8" title="1">
                return http.StatusConflict</span>
        default:<span class="cov8" title="1">
                return http.StatusInternalServerError</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package db

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/apperrors"
        "github.com/jmoiron/sqlx"
        _ "modernc.org/sqlite"
)

// Errors
var (
        ErrArticleNotFound  = errors.New("article not found")
        ErrFeedbackNotFound = errors.New("feedback not found")
        ErrDuplicateURL     = errors.New("article with this URL already exists")
)

// Article represents a news article with bias information
type Article struct {
        ID             int64     `db:"id" json:"id"`
        Source         string    `db:"source" json:"source"`
        PubDate        time.Time `db:"pub_date" json:"pub_date"`
        URL            string    `db:"url" json:"url"`
        Title          string    `db:"title" json:"title"`
        Content        string    `db:"content" json:"content"`
        CreatedAt      time.Time `db:"created_at" json:"created_at"`
        CompositeScore *float64  `db:"composite_score" json:"composite_score,omitempty"`
        Confidence     *float64  `db:"confidence" json:"confidence,omitempty"`
        ScoreSource    *string   `db:"score_source" json:"score_source,omitempty"`
}

// LLMScore represents a political bias score from an LLM model
type LLMScore struct {
        ID        int64     `db:"id" json:"id"`
        ArticleID int64     `db:"article_id" json:"article_id"`
        Model     string    `db:"model" json:"model"`
        Score     float64   `db:"score" json:"score"`
        Metadata  string    `db:"metadata" json:"metadata"`
        Version   string    `db:"version" json:"version"`
        CreatedAt time.Time `db:"created_at" json:"created_at"`
}

// Feedback represents user feedback on an article
type Feedback struct {
        ID               int64     `db:"id" json:"id"`
        ArticleID        int64     `db:"article_id" json:"article_id"`
        UserID           string    `db:"user_id" json:"user_id"`
        FeedbackText     string    `db:"feedback_text" json:"feedback_text"`
        Category         string    `db:"category" json:"category"`
        EnsembleOutputID *int64    `db:"ensemble_output_id" json:"ensemble_output_id,omitempty"`
        Source           string    `db:"source" json:"source,omitempty"`
        CreatedAt        time.Time `db:"created_at" json:"created_at"`
}

// Label represents a training label for the system
type Label struct {
        ID          int64     `db:"id" json:"id"`
        Data        string    `db:"data" json:"data"`
        Label       string    `db:"label" json:"label"`
        Source      string    `db:"source" json:"source"`
        DateLabeled time.Time `db:"date_labeled" json:"date_labeled"`
        Labeler     string    `db:"labeler" json:"labeler"`
        Confidence  float64   `db:"confidence" json:"confidence"`
        CreatedAt   time.Time `db:"created_at" json:"created_at"`
}

// ArticleFilter defines filters for retrieving articles
type ArticleFilter struct {
        Source  string
        Leaning string
        Limit   int
        Offset  int
}

// ArticleScore represents a score update for an article
type ArticleScore struct {
        Score      float64 `json:"score"`
        Confidence float64 `json:"confidence"`
        Source     string  `json:"source"`
}

// ArticleFeedback represents feedback for an article
type ArticleFeedback struct {
        ArticleID        int64     `json:"article_id"`
        UserID           string    `json:"user_id"`
        FeedbackText     string    `json:"feedback_text"`
        Category         string    `json:"category"`
        EnsembleOutputID *int64    `json:"ensemble_output_id,omitempty"`
        Source           string    `json:"source,omitempty"`
        CreatedAt        time.Time `json:"created_at"`
}

// DBOperations defines the interface for database operations
type DBOperations interface {
        // Article retrieval operations
        GetArticleByID(ctx context.Context, id int64) (*Article, error)
        FetchArticleByID(ctx context.Context, id int64) (*Article, error) // Alias for GetArticleByID
        GetArticles(ctx context.Context, filter ArticleFilter) ([]*Article, error)
        FetchArticles(ctx context.Context, source, leaning string, limit, offset int) ([]*Article, error) // Used in handlers

        // Article creation/update operations
        InsertArticle(ctx context.Context, article *Article) (int64, error)
        UpdateArticleScore(ctx context.Context, articleID int64, score float64, confidence float64) error
        UpdateArticleScoreObj(ctx context.Context, articleID int64, score *ArticleScore, confidence float64) error
        ArticleExistsByURL(ctx context.Context, url string) (bool, error)

        // Feedback operations
        SaveArticleFeedback(ctx context.Context, feedback *ArticleFeedback) error
        InsertFeedback(ctx context.Context, feedback *Feedback) error

        // LLM Score operations
        FetchLLMScores(ctx context.Context, articleID int64) ([]LLMScore, error)
}

// DBInstance implements the DBOperations interface
type DBInstance struct {
        DB *sqlx.DB
}

// GetArticleByID retrieves an article by ID
func (d *DBInstance) GetArticleByID(ctx context.Context, id int64) (*Article, error) <span class="cov0" title="0">{
        return FetchArticleByID(d.DB, id)
}</span>

// FetchArticleByID is an alias for GetArticleByID
func (d *DBInstance) FetchArticleByID(ctx context.Context, id int64) (*Article, error) <span class="cov0" title="0">{
        return FetchArticleByID(d.DB, id)
}</span>

// GetArticles retrieves articles based on filter criteria
func (d *DBInstance) GetArticles(ctx context.Context, filter ArticleFilter) ([]*Article, error) <span class="cov0" title="0">{
        articles, err := FetchArticles(d.DB, filter.Source, filter.Leaning, filter.Limit, filter.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert from []Article to []*Article
        <span class="cov0" title="0">result := make([]*Article, len(articles))
        for i := range articles </span><span class="cov0" title="0">{
                result[i] = &amp;articles[i]
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// FetchArticles retrieves articles using source, leaning, limit and offset parameters
func (d *DBInstance) FetchArticles(ctx context.Context, source, leaning string, limit, offset int) ([]*Article, error) <span class="cov0" title="0">{
        articles, err := FetchArticles(d.DB, source, leaning, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert from []Article to []*Article
        <span class="cov0" title="0">result := make([]*Article, len(articles))
        for i := range articles </span><span class="cov0" title="0">{
                result[i] = &amp;articles[i]
        }</span>
        <span class="cov0" title="0">return result, nil</span>
}

// InsertArticle inserts a new article
func (d *DBInstance) InsertArticle(ctx context.Context, article *Article) (int64, error) <span class="cov0" title="0">{
        return InsertArticle(d.DB, article)
}</span>

// UpdateArticleScore updates an article's score
func (d *DBInstance) UpdateArticleScore(ctx context.Context, articleID int64, score float64, confidence float64) error <span class="cov0" title="0">{
        return UpdateArticleScore(d.DB, articleID, score, confidence)
}</span>

// UpdateArticleScoreObj updates an article's score using an ArticleScore object
func (d *DBInstance) UpdateArticleScoreObj(ctx context.Context, articleID int64, score *ArticleScore, confidence float64) error <span class="cov0" title="0">{
        if score == nil </span><span class="cov0" title="0">{
                return errors.New("score cannot be nil")
        }</span>
        <span class="cov0" title="0">return UpdateArticleScore(d.DB, articleID, score.Score, confidence)</span>
}

// ArticleExistsByURL checks if an article exists by URL
func (d *DBInstance) ArticleExistsByURL(ctx context.Context, url string) (bool, error) <span class="cov0" title="0">{
        return ArticleExistsByURL(d.DB, url)
}</span>

// SaveArticleFeedback saves article feedback
func (d *DBInstance) SaveArticleFeedback(ctx context.Context, feedback *ArticleFeedback) error <span class="cov0" title="0">{
        if feedback == nil </span><span class="cov0" title="0">{
                return errors.New("feedback cannot be nil")
        }</span>
        <span class="cov0" title="0">dbFeedback := &amp;Feedback{
                ArticleID:        feedback.ArticleID,
                UserID:           feedback.UserID,
                FeedbackText:     feedback.FeedbackText,
                Category:         feedback.Category,
                EnsembleOutputID: feedback.EnsembleOutputID,
                Source:           feedback.Source,
                CreatedAt:        time.Now(),
        }
        return InsertFeedback(d.DB, dbFeedback)</span>
}

// InsertFeedback inserts article feedback
func (d *DBInstance) InsertFeedback(ctx context.Context, feedback *Feedback) error <span class="cov0" title="0">{
        return InsertFeedback(d.DB, feedback)
}</span>

// FetchLLMScores retrieves LLM scores for an article
func (d *DBInstance) FetchLLMScores(ctx context.Context, articleID int64) ([]LLMScore, error) <span class="cov0" title="0">{
        return FetchLLMScores(d.DB, articleID)
}</span>

// New creates a new database connection
func New(connString string) (*DBInstance, error) <span class="cov8" title="1">{
        db, err := sqlx.Open("sqlite", connString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;DBInstance{DB: db}, nil</span>
}

// Close closes the database connection
func (d *DBInstance) Close() error <span class="cov8" title="1">{
        return d.DB.Close()
}</span>

// handleError is a helper to wrap database errors with appropriate context
func handleError(err error, msg string) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()
        switch </span>{
        case err == sql.ErrNoRows:<span class="cov0" title="0">
                return apperrors.New("not_found", msg)</span>
        case strings.Contains(errMsg, "UNIQUE constraint"):<span class="cov8" title="1">
                return apperrors.New("conflict", msg)</span>
        case strings.Contains(errMsg, "FOREIGN KEY constraint"):<span class="cov0" title="0">
                return apperrors.New("foreign_key_violation", msg)</span>
        default:<span class="cov0" title="0">
                return apperrors.New("internal", msg)</span>
        }
}

// InsertLabel inserts a new label record
func InsertLabel(db *sqlx.DB, label *Label) error <span class="cov8" title="1">{
        result, err := db.NamedExec(`
        INSERT INTO labels (data, label, source, date_labeled, labeler, confidence, created_at)
        VALUES (:data, :label, :source, :date_labeled, :labeler, :confidence, :created_at)`,
                label)
        if err != nil </span><span class="cov0" title="0">{
                return handleError(err, "failed to insert label")
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return handleError(err, "failed to get inserted label ID")
        }</span>
        <span class="cov8" title="1">label.ID = id
        return nil</span>
}

// InsertFeedback stores user feedback for an article
func InsertFeedback(db *sqlx.DB, feedback *Feedback) error <span class="cov8" title="1">{
        result, err := db.NamedExec(`
        INSERT INTO feedback (article_id, user_id, feedback_text, category, ensemble_output_id, source, created_at)
        VALUES (:article_id, :user_id, :feedback_text, :category, :ensemble_output_id, :source, :created_at)`,
                feedback)
        if err != nil </span><span class="cov0" title="0">{
                return handleError(err, "failed to insert feedback")
        }</span>

        <span class="cov8" title="1">id, err := result.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return handleError(err, "failed to get inserted feedback ID")
        }</span>
        <span class="cov8" title="1">feedback.ID = id
        return nil</span>
}

// FetchLatestEnsembleScore gets the most recent ensemble score for an article
func FetchLatestEnsembleScore(db *sqlx.DB, articleID int64) (float64, error) <span class="cov8" title="1">{
        var score float64
        err := db.Get(&amp;score, `
        SELECT score FROM llm_scores 
        WHERE article_id = ? AND model = 'ensemble'
        ORDER BY created_at DESC LIMIT 1`,
                articleID)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return 0.0, nil // Return 0 if no score exists
                }</span>
                <span class="cov0" title="0">return 0.0, handleError(err, "failed to fetch latest ensemble score")</span>
        }
        <span class="cov8" title="1">return score, nil</span>
}

// FetchLatestConfidence gets the most recent confidence score for an article
func FetchLatestConfidence(db *sqlx.DB, articleID int64) (float64, error) <span class="cov8" title="1">{
        var confidence float64
        err := db.Get(&amp;confidence, `
        SELECT confidence FROM articles WHERE id = ?`,
                articleID)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return 0.0, nil // Return 0 if no confidence exists
                }</span>
                <span class="cov0" title="0">return 0.0, handleError(err, "failed to fetch latest confidence score")</span>
        }
        <span class="cov8" title="1">return confidence, nil</span>
}

// ArticleExistsBySimilarTitle checks if an article with a similar title exists
func ArticleExistsBySimilarTitle(db *sqlx.DB, title string) (bool, error) <span class="cov8" title="1">{
        // Normalize input title: lowercase and remove punctuation/spaces
        cleanTitle := strings.ToLower(strings.TrimSpace(title))
        for _, r := range []string{"'", `"`, ",", "!", ".", "?", ";", ":", " "} </span><span class="cov8" title="1">{
                cleanTitle = strings.ReplaceAll(cleanTitle, r, "")
        }</span>

        <span class="cov8" title="1">var exists bool
        err := db.Get(&amp;exists, `
            SELECT EXISTS(
                SELECT 1 FROM articles
                WHERE LOWER(
                    REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(title, "'", ""), '"', ""), ' ', ""), ',', ""), '!', ""), '.', ""), '?', ""), ';', "")
                ) LIKE '%' || ? || '%'
            )`, cleanTitle)
        if err != nil </span><span class="cov0" title="0">{
                return false, handleError(err, "failed to check for similar title")
        }</span>
        <span class="cov8" title="1">return exists, nil</span>
}

// InsertArticle creates a new article record
func InsertArticle(db *sqlx.DB, article *Article) (int64, error) <span class="cov8" title="1">{
        result, err := db.NamedExec(`
        INSERT INTO articles (source, pub_date, url, title, content, created_at, composite_score, confidence, score_source)
        VALUES (:source, :pub_date, :url, :title, :content, :created_at, :composite_score, :confidence, :score_source)`,
                article)
        if err != nil </span><span class="cov8" title="1">{
                return 0, handleError(err, "failed to insert article")
        }</span>
        <span class="cov8" title="1">return result.LastInsertId()</span>
}

// InsertLLMScore creates a new LLM score record
func InsertLLMScore(exec sqlx.ExtContext, score *LLMScore) (int64, error) <span class="cov8" title="1">{
        result, err := sqlx.NamedExecContext(context.Background(), exec, `
        INSERT INTO llm_scores (article_id, model, score, metadata, version, created_at)
        VALUES (:article_id, :model, :score, :metadata, :version, :created_at)`,
                score)
        if err != nil </span><span class="cov0" title="0">{
                return 0, handleError(err, "failed to insert LLM score")
        }</span>
        <span class="cov8" title="1">return result.LastInsertId()</span>
}

// FetchArticles retrieves articles with optional filters
func FetchArticles(db *sqlx.DB, source string, leaning string, limit int, offset int) ([]Article, error) <span class="cov8" title="1">{
        query := `SELECT * FROM articles WHERE 1=1`
        var args []interface{}

        if source != "" </span><span class="cov8" title="1">{
                query += " AND source = ?"
                args = append(args, source)
        }</span>
        <span class="cov8" title="1">if leaning != "" </span><span class="cov8" title="1">{
                switch leaning </span>{
                case "left":<span class="cov8" title="1">
                        query += " AND composite_score &lt; -0.1"</span>
                case "right":<span class="cov8" title="1">
                        query += " AND composite_score &gt; 0.1"</span>
                case "center":<span class="cov8" title="1">
                        query += " AND composite_score BETWEEN -0.1 AND 0.1"</span>
                }
        }

        <span class="cov8" title="1">query += " ORDER BY created_at DESC LIMIT ? OFFSET ?"
        args = append(args, limit, offset)

        // Add debug logging
        log.Printf("[DEBUG] FetchArticles query: %s with args: %v", query, args)

        // Use db.Unsafe() to allow scanning of null values
        unsafe := db.Unsafe()
        var articles []Article
        err := unsafe.Select(&amp;articles, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ERROR] FetchArticles failed: %v", err)
                return nil, handleError(err, "failed to fetch articles")
        }</span>

        <span class="cov8" title="1">log.Printf("[INFO] FetchArticles found %d articles", len(articles))
        return articles, nil</span>
}

// FetchArticleByID retrieves a single article by ID
func FetchArticleByID(db *sqlx.DB, id int64) (*Article, error) <span class="cov8" title="1">{
        var article Article

        // Add retry logic with backoff for recently created articles
        maxRetries := 3
        retryDelay := 100 * time.Millisecond

        var err error
        for attempt := 0; attempt &lt; maxRetries; attempt++ </span><span class="cov8" title="1">{
                err = db.Get(&amp;article, "SELECT * FROM articles WHERE id = ?", id)
                if err == nil </span><span class="cov8" title="1">{
                        // Article found, return it
                        return &amp;article, nil
                }</span>

                <span class="cov8" title="1">if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        // For errors other than "no rows", log the specific error
                        log.Printf("[ERROR] FetchArticleByID %d failed (attempt %d): %v", id, attempt+1, err)
                        // Don't retry for database errors
                        break</span>
                }

                <span class="cov8" title="1">log.Printf("[INFO] FetchArticleByID %d: article not found, retrying after %v (attempt %d of %d)", id, retryDelay, attempt+1, maxRetries)
                // Only for "no rows" error, wait and retry
                // This helps with timing issues when an article was just created
                // but the transaction hasn't fully committed yet
                if attempt &lt; maxRetries-1 </span><span class="cov8" title="1">{
                        time.Sleep(retryDelay)
                        retryDelay *= 2 // Exponential backoff
                }</span>
        }

        // Handle the final error
        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                log.Printf("[WARN] FetchArticleByID %d: article not found after %d attempts", id, maxRetries)
                return nil, ErrArticleNotFound
        }</span>
        <span class="cov0" title="0">log.Printf("[ERROR] FetchArticleByID %d failed with database error: %v", id, err)
        return nil, handleError(err, "failed to fetch article")</span>
}

// FetchLLMScores retrieves all LLM scores for an article
func FetchLLMScores(db *sqlx.DB, articleID int64) ([]LLMScore, error) <span class="cov8" title="1">{
        var scores []LLMScore
        err := db.Select(&amp;scores, "SELECT * FROM llm_scores WHERE article_id = ? ORDER BY created_at DESC", articleID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, handleError(err, "failed to fetch LLM scores")
        }</span>
        <span class="cov8" title="1">return scores, nil</span>
}

// UpdateArticleScore updates the composite score for an article
func UpdateArticleScore(db *sqlx.DB, articleID int64, score float64, confidence float64) error <span class="cov8" title="1">{
        _, err := db.Exec(`
        UPDATE articles 
        SET composite_score = ?, confidence = ?, score_source = 'llm'
        WHERE id = ?`,
                score, confidence, articleID)
        if err != nil </span><span class="cov0" title="0">{
                return handleError(err, "failed to update article score")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateArticleScoreLLM updates the composite score for an article, specifically from LLM rescoring
func UpdateArticleScoreLLM(exec sqlx.ExtContext, articleID int64, score float64, confidence float64) error <span class="cov8" title="1">{
        _, err := exec.ExecContext(context.Background(), `
        UPDATE articles 
        SET composite_score = ?, confidence = ?, score_source = 'llm'
        WHERE id = ?`,
                score, confidence, articleID)
        if err != nil </span><span class="cov0" title="0">{
                return handleError(err, "failed to update article score (LLM)")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ArticleExistsByURL checks if an article exists with the given URL
func ArticleExistsByURL(db *sqlx.DB, url string) (bool, error) <span class="cov8" title="1">{
        var exists bool
        err := db.Get(&amp;exists, "SELECT EXISTS(SELECT 1 FROM articles WHERE url = ?)", url)
        if err != nil </span><span class="cov0" title="0">{
                return false, handleError(err, "failed to check article URL existence")
        }</span>
        <span class="cov8" title="1">return exists, nil</span>
}

// InitDB initializes and returns a database connection to the specified SQLite database file
func InitDB(dbPath string) (*sqlx.DB, error) <span class="cov0" title="0">{
        // Open SQLite database connection
        db, err := sqlx.Open("sqlite", dbPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Verify database connection is working
        <span class="cov0" title="0">if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Set connection properties
        <span class="cov0" title="0">db.SetMaxOpenConns(10)
        db.SetMaxIdleConns(5)
        db.SetConnMaxLifetime(time.Hour)

        // Return the database connection
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package llm

import (
        "encoding/json"
        "fmt"
        "sync"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
)

// Cache provides a thread-safe in-memory cache
type Cache struct {
        m sync.Map
}

// NewCache creates a new empty cache instance
func NewCache() *Cache <span class="cov8" title="1">{
        return &amp;Cache{}
}</span>

// makeKey creates a composite key from content hash and model
func makeKey(contentHash, model string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%s", contentHash, model)
}</span>

// Get retrieves a value from the cache
func (c *Cache) Get(contentHash, model string) (*db.LLMScore, bool) <span class="cov8" title="1">{
        v, ok := c.m.Load(makeKey(contentHash, model))
        if !ok </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        // Convert stored JSON string back to LLMScore
        <span class="cov8" title="1">var score db.LLMScore
        if err := json.Unmarshal([]byte(v.(string)), &amp;score); err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">return &amp;score, true</span>
}

// Set stores a value in the cache
func (c *Cache) Set(contentHash, model string, score *db.LLMScore) <span class="cov8" title="1">{
        // Convert LLMScore to JSON string for storage
        data, err := json.Marshal(score)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">c.m.Store(makeKey(contentHash, model), string(data))</span>
}

// Delete removes a value from the cache
func (c *Cache) Delete(key string) <span class="cov8" title="1">{
        c.m.Delete(key)
}</span>

// Remove removes a value from the cache by content hash and model
func (c *Cache) Remove(contentHash, model string) <span class="cov8" title="1">{
        c.m.Delete(makeKey(contentHash, model))
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package llm

import (
        "encoding/json"
        "fmt"
        "log"
        "strings"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
)

// MapModelToPerspective maps a model name to its perspective (left, center, right)
// based on the provided composite score configuration
func MapModelToPerspective(modelName string, cfg *CompositeScoreConfig) string <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov8" title="1">{
                log.Printf("Error: CompositeScoreConfig is nil in MapModelToPerspective")
                return ""
        }</span>

        <span class="cov8" title="1">normalizedModelName := strings.ToLower(strings.TrimSpace(modelName))

        // Look up the model in the configuration
        for _, model := range cfg.Models </span><span class="cov8" title="1">{
                if strings.ToLower(strings.TrimSpace(model.ModelName)) == normalizedModelName </span><span class="cov8" title="1">{
                        return strings.ToLower(model.Perspective)
                }</span>
        }

        // Fallback to legacy names
        <span class="cov8" title="1">if normalizedModelName == "left" </span><span class="cov8" title="1">{
                return "left"
        }</span> else<span class="cov8" title="1"> if normalizedModelName == "center" </span><span class="cov8" title="1">{
                return "center"
        }</span> else<span class="cov8" title="1"> if normalizedModelName == "right" </span><span class="cov8" title="1">{
                return "right"
        }</span>

        <span class="cov8" title="1">log.Printf("Warning: Model '%s' not found in composite score configuration", modelName)
        return ""</span>
}

// checkForAllZeroResponses detects if all LLM responses have zero scores and zero confidence
func checkForAllZeroResponses(scores []db.LLMScore) (bool, error) <span class="cov8" title="1">{
        if len(scores) == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("no LLM scores provided")
        }</span>

        <span class="cov8" title="1">allZeros := true
        for _, score := range scores </span><span class="cov8" title="1">{
                // Check if we have a non-zero score
                if score.Score != 0.0 </span><span class="cov8" title="1">{
                        allZeros = false
                        break</span>
                }

                // Extract confidence from metadata
                <span class="cov8" title="1">var metadata map[string]interface{}
                if err := json.Unmarshal([]byte(score.Metadata), &amp;metadata); err == nil </span><span class="cov8" title="1">{
                        if confidence, ok := metadata["confidence"].(float64); ok &amp;&amp; confidence &gt; 0.0 </span><span class="cov0" title="0">{
                                allZeros = false
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if allZeros </span><span class="cov8" title="1">{
                log.Printf("Critical warning: All %d LLM models returned empty responses or zero values", len(scores))
                return true, fmt.Errorf("all LLMs returned empty or zero-confidence responses (count: %d)", len(scores))
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}

// ComputeCompositeScoreWithConfidenceFixed is an improved version of ComputeCompositeScoreWithConfidence
// that properly maps model names to their perspectives based on the configuration
func ComputeCompositeScoreWithConfidenceFixed(scores []db.LLMScore) (float64, float64, error) <span class="cov8" title="1">{
        // First check if we have all zero responses
        if allZeros, err := checkForAllZeroResponses(scores); allZeros </span><span class="cov8" title="1">{
                return 0, 0, err
        }</span>

        // Use the global test config if available (for tests), otherwise load from file
        <span class="cov8" title="1">var cfg *CompositeScoreConfig
        var err error

        if testModelConfig != nil </span><span class="cov8" title="1">{
                cfg = testModelConfig
        }</span> else<span class="cov8" title="1"> {
                cfg, err = LoadCompositeScoreConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, fmt.Errorf("loading composite score config: %w", err)
                }</span>
        }

        // Map for left/center/right
        <span class="cov8" title="1">scoreMap := map[string]float64{
                "left":   cfg.DefaultMissing,
                "center": cfg.DefaultMissing,
                "right":  cfg.DefaultMissing,
        }

        validCount := 0
        sum := 0.0
        weightedSum := 0.0
        weightTotal := 0.0
        validModels := make(map[string]bool)

        // Log the scores we're processing
        log.Printf("ComputeCompositeScoreWithConfidenceFixed: Processing %d scores", len(scores))
        for i, s := range scores </span><span class="cov8" title="1">{
                log.Printf("Score[%d]: Model=%s, Score=%.2f", i, s.Model, s.Score)
        }</span>

        // Process scores by perspective
        <span class="cov8" title="1">perspectiveModels := mapModelsToPerspectives(scores, cfg)
        processScoresByPerspective(perspectiveModels, cfg, scoreMap, &amp;validCount, &amp;validModels)

        if validCount == 0 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("no valid model scores to compute composite score (input count: %d)", len(scores))
        }</span>

        // Calculate weighted sums
        <span class="cov8" title="1">for k, v := range scoreMap </span><span class="cov8" title="1">{
                score := v
                w := 1.0
                if cfg.Formula == "weighted" </span><span class="cov0" title="0">{
                        if weight, ok := cfg.Weights[k]; ok </span><span class="cov0" title="0">{
                                w = weight
                        }</span>
                }
                <span class="cov8" title="1">weightedSum += score * w
                weightTotal += w
                sum += score</span>
        }

        // Calculate composite score
        <span class="cov8" title="1">composite := calculateCompositeScore(cfg, scoreMap, sum, weightedSum, weightTotal)

        // Calculate confidence using the proper calculation function
        confidence := calculateConfidence(cfg, &amp;validModels, scoreMap)

        log.Printf("ComputeCompositeScoreWithConfidenceFixed: Final composite=%.2f, confidence=%.2f", composite, confidence)
        return composite, confidence, nil</span>
}

// processScoresByPerspective handles selecting the best score for each perspective
func processScoresByPerspective(
        perspectiveModels map[string][]db.LLMScore,
        cfg *CompositeScoreConfig,
        scoreMap map[string]float64,
        validCount *int,
        validModels *map[string]bool) <span class="cov8" title="1">{

        // Use the best score from each perspective
        for perspective, models := range perspectiveModels </span><span class="cov8" title="1">{
                if len(models) == 0 </span><span class="cov0" title="0">{
                        log.Printf("No models found for perspective %s", perspective)
                        continue</span>
                }

                <span class="cov8" title="1">log.Printf("Candidates for %s: ", perspective)
                for _, m := range models </span><span class="cov8" title="1">{
                        log.Printf("  Model: %s, Score: %.2f, Metadata: %s", m.Model, m.Score, m.Metadata)
                }</span>

                // Find the model with highest confidence
                <span class="cov8" title="1">bestScore := findBestConfidenceScore(models)
                log.Printf("Selected for %s: Model: %s, Score: %.2f", perspective, bestScore.Model, bestScore.Score)

                // Use the best score for this perspective
                val := bestScore.Score

                // Only consider a score invalid if it's truly invalid (NaN, +/-Inf)
                // or outside the configured range when specified
                hasScoreRange := cfg.MinScore &gt; -1e9 || cfg.MaxScore &lt; 1e9
                isOutsideRange := hasScoreRange &amp;&amp; (val &lt; cfg.MinScore || val &gt; cfg.MaxScore)

                if cfg.HandleInvalid == "ignore" &amp;&amp; (isInvalid(val) || isOutsideRange) </span><span class="cov0" title="0">{
                        log.Printf("Ignoring invalid score %.2f for perspective %s", val, perspective)
                        continue</span>
                }

                <span class="cov8" title="1">if isInvalid(val) || isOutsideRange </span><span class="cov0" title="0">{
                        val = cfg.DefaultMissing
                        log.Printf("Using default value %.2f for invalid score from perspective %s", val, perspective)
                }</span> else<span class="cov8" title="1"> {
                        log.Printf("Using actual score %.2f for perspective %s from model %s", val, perspective, bestScore.Model)
                }</span>

                <span class="cov8" title="1">log.Printf("Adding score %.2f for perspective %s from model %s", val, perspective, bestScore.Model)
                scoreMap[perspective] = val
                (*validCount)++
                (*validModels)[perspective] = true</span>
        }
}

// mapModelsToPerspectives groups LLM scores by their corresponding perspectives
func mapModelsToPerspectives(scores []db.LLMScore, cfg *CompositeScoreConfig) map[string][]db.LLMScore <span class="cov8" title="1">{
        perspectiveModels := make(map[string][]db.LLMScore)
        for _, s := range scores </span><span class="cov8" title="1">{
                // Skip ensemble scores
                if strings.ToLower(s.Model) == "ensemble" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // First try to map the model to its perspective
                <span class="cov8" title="1">perspective := MapModelToPerspective(s.Model, cfg)

                // If mapping failed, try the old way (legacy model names)
                if perspective == "" </span><span class="cov8" title="1">{
                        model := strings.ToLower(s.Model)
                        // Direct check for legacy model names - these are the model names themselves
                        if model == "left" </span><span class="cov0" title="0">{
                                perspective = "left"
                        }</span> else<span class="cov8" title="1"> if model == "center" </span><span class="cov0" title="0">{
                                perspective = "center"
                        }</span> else<span class="cov8" title="1"> if model == "right" </span><span class="cov0" title="0">{
                                perspective = "right"
                        }</span> else<span class="cov8" title="1"> if model == LabelLeft </span><span class="cov0" title="0">{
                                perspective = "left"
                        }</span> else<span class="cov8" title="1"> if model == LabelRight </span><span class="cov0" title="0">{
                                perspective = "right"
                        }</span> else<span class="cov8" title="1"> {
                                // Skip unknown models
                                log.Printf("Skipping unknown model: %s", s.Model)
                                continue</span>
                        }
                }

                // Ensure perspective is one of the expected values
                <span class="cov8" title="1">if perspective != "left" &amp;&amp; perspective != "center" &amp;&amp; perspective != "right" </span><span class="cov0" title="0">{
                        log.Printf("Skipping model with invalid perspective: %s -&gt; %s", s.Model, perspective)
                        continue</span>
                }

                // Add to perspective models map
                <span class="cov8" title="1">log.Printf("Mapping model '%s' (score %.2f) to perspective '%s'", s.Model, s.Score, perspective)
                perspectiveModels[perspective] = append(perspectiveModels[perspective], s)</span>
        }

        // Log the perspective mapping results
        <span class="cov8" title="1">for perspective, models := range perspectiveModels </span><span class="cov8" title="1">{
                log.Printf("Perspective %s has %d models", perspective, len(models))
        }</span>

        <span class="cov8" title="1">return perspectiveModels</span>
}

// findBestConfidenceScore selects the score with highest confidence from a group of models
func findBestConfidenceScore(models []db.LLMScore) db.LLMScore <span class="cov8" title="1">{
        if len(models) == 1 </span><span class="cov8" title="1">{
                return models[0]
        }</span>

        <span class="cov8" title="1">bestScore := models[0]
        bestConfidence := extractConfidence(bestScore.Metadata)
        allSameConfidence := true

        for _, model := range models[1:] </span><span class="cov8" title="1">{
                modelConfidence := extractConfidence(model.Metadata)
                if modelConfidence != bestConfidence </span><span class="cov8" title="1">{
                        allSameConfidence = false
                }</span>
                <span class="cov8" title="1">if modelConfidence &gt; bestConfidence </span><span class="cov8" title="1">{
                        bestScore = model
                        bestConfidence = modelConfidence
                }</span> else<span class="cov8" title="1"> if modelConfidence == bestConfidence </span><span class="cov8" title="1">{
                        if model.Score &gt; bestScore.Score </span><span class="cov0" title="0">{
                                bestScore = model
                        }</span>
                }
        }

        // If all confidences are equal, pick the highest score
        <span class="cov8" title="1">if allSameConfidence </span><span class="cov8" title="1">{
                maxScore := bestScore.Score
                for _, model := range models </span><span class="cov8" title="1">{
                        if model.Score &gt; maxScore </span><span class="cov0" title="0">{
                                bestScore = model
                                maxScore = model.Score
                        }</span>
                }
        }

        <span class="cov8" title="1">return bestScore</span>
}

// extractConfidence gets the confidence value from model metadata, defaulting to 0.5
func extractConfidence(metadata string) float64 <span class="cov8" title="1">{
        defaultConfidence := 0.5

        var metaMap map[string]interface{}
        if err := json.Unmarshal([]byte(metadata), &amp;metaMap); err != nil </span><span class="cov8" title="1">{
                return defaultConfidence
        }</span>

        <span class="cov8" title="1">if conf, ok := metaMap["confidence"].(float64); ok </span><span class="cov8" title="1">{
                return conf
        }</span>

        <span class="cov0" title="0">return defaultConfidence</span>
}

// calculateCompositeScore computes the final score based on the configured formula
func calculateCompositeScore(cfg *CompositeScoreConfig, scoreMap map[string]float64,
        sum, weightedSum, weightTotal float64) float64 <span class="cov8" title="1">{

        var composite float64
        switch cfg.Formula </span>{
        case "average":<span class="cov8" title="1">
                composite = sum / 3.0</span>
        case "weighted":<span class="cov0" title="0">
                if weightTotal &gt; 0 </span><span class="cov0" title="0">{
                        composite = weightedSum / weightTotal
                }</span> else<span class="cov0" title="0"> {
                        composite = 0.0
                }</span>
        case "min":<span class="cov0" title="0">
                composite = minNonNil(scoreMap, cfg.DefaultMissing)</span>
        case "max":<span class="cov0" title="0">
                composite = maxNonNil(scoreMap, cfg.DefaultMissing)</span>
        default:<span class="cov0" title="0">
                composite = sum / 3.0</span>
        }

        <span class="cov8" title="1">return composite</span>
}

// calculateConfidence determines the confidence level based on the configured method
func calculateConfidence(cfg *CompositeScoreConfig, validModels *map[string]bool,
        scoreMap map[string]float64) float64 <span class="cov8" title="1">{

        var confidence float64
        switch cfg.ConfidenceMethod </span>{
        case "count_valid":<span class="cov8" title="1">
                confidence = float64(len(*validModels)) / 3.0</span>
        case "spread":<span class="cov0" title="0">
                confidence = 1.0 - scoreSpread(scoreMap)</span>
        default:<span class="cov0" title="0">
                confidence = float64(len(*validModels)) / 3.0</span>
        }

        <span class="cov8" title="1">if confidence &lt; cfg.MinConfidence </span><span class="cov0" title="0">{
                confidence = cfg.MinConfidence
        }</span>
        <span class="cov8" title="1">if confidence &gt; cfg.MaxConfidence </span><span class="cov8" title="1">{
                confidence = cfg.MaxConfidence
        }</span>

        <span class="cov8" title="1">return confidence</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package llm

import (
        "encoding/json"
        "fmt"
        "os"
        "sort"
        "sync"
)

var (
        // fileCompositeScoreConfig caches the config loaded from file
        fileCompositeScoreConfig     *CompositeScoreConfig
        fileCompositeScoreConfigOnce sync.Once
)

// LoadCompositeScoreConfig loads the composite score configuration from file
func LoadCompositeScoreConfig() (*CompositeScoreConfig, error) <span class="cov8" title="1">{
        var err error
        fileCompositeScoreConfigOnce.Do(func() </span><span class="cov8" title="1">{
                const configPath = "configs/composite_score_config.json"
                f, e := os.Open(configPath)
                if e != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("opening composite score config %q: %w", configPath, e)
                        return
                }</span>
                <span class="cov8" title="1">defer f.Close()
                decoder := json.NewDecoder(f)
                var cfg CompositeScoreConfig
                if e := decoder.Decode(&amp;cfg); e != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("decoding composite score config %q: %w", configPath, e)
                        return
                }</span>
                <span class="cov8" title="1">if len(cfg.Models) == 0 </span><span class="cov0" title="0">{
                        err = fmt.Errorf("composite score config %q loaded but contains no models", configPath)
                        return
                }</span>
                <span class="cov8" title="1">fileCompositeScoreConfig = &amp;cfg</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return fileCompositeScoreConfig, nil</span>
}

// minNonNil returns the minimum value from a map of float64s
func minNonNil(m map[string]float64, def float64) float64 <span class="cov8" title="1">{
        min := def
        first := true
        for _, v := range m </span><span class="cov8" title="1">{
                if first || v &lt; min </span><span class="cov8" title="1">{
                        min = v
                        first = false
                }</span>
        }
        <span class="cov8" title="1">return min</span>
}

// maxNonNil returns the maximum value from a map of float64s
func maxNonNil(m map[string]float64, def float64) float64 <span class="cov8" title="1">{
        max := def
        first := true
        for _, v := range m </span><span class="cov8" title="1">{
                if first || v &gt; max </span><span class="cov8" title="1">{
                        max = v
                        first = false
                }</span>
        }
        <span class="cov8" title="1">return max</span>
}

// scoreSpread calculates the difference between the maximum and minimum score
func scoreSpread(m map[string]float64) float64 <span class="cov8" title="1">{
        vals := []float64{}
        for _, v := range m </span><span class="cov8" title="1">{
                vals = append(vals, v)
        }</span>
        <span class="cov8" title="1">if len(vals) &lt; 2 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">sort.Float64s(vals)
        return vals[len(vals)-1] - vals[0]</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package llm

import (
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "log"
        "math"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
)

// callLLM queries a specific LLM with a prompt variant
func (c *LLMClient) callLLM(articleID int64, modelName string, promptVariant PromptVariant, content string) (float64, string, float64, string, error) <span class="cov0" title="0">{
        maxRetries := 2
        var lastErr error
        var rawResp string
        var score, confidence float64
        var explanation string

        for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                prompt := promptVariant.FormatPrompt(content)

                // Compute prompt hash for logging
                h := sha256.Sum256([]byte(prompt))
                promptHash := fmt.Sprintf("%x", h[:8]) // first 8 bytes as hex string
                promptSnippet := prompt
                if len(promptSnippet) &gt; 80 </span><span class="cov0" title="0">{
                        promptSnippet = promptSnippet[:80] + "..."
                }</span>
                <span class="cov0" title="0">log.Printf("Prompt snippet [%s] (attempt %d): %s", promptHash, attempt+1, promptSnippet)

                var err error
                // Use the generic LLM service stored in the client
                if c.llmService == nil </span><span class="cov0" title="0">{
                        log.Printf("[LLM] ArticleID %d | Model %s | PromptHash %s | LLM service not initialized", articleID, modelName, promptHash)
                        return 0, "", 0, "", fmt.Errorf("LLM service not initialized")
                }</span>

                // We need the raw response string and the parsed score/confidence/explanation.
                // The current HTTPLLMService.AnalyzeWithPrompt returns a *db.LLMScore which contains metadata,
                // but not necessarily the raw response string needed for parseLLMResponse here.
                // Let's adapt by calling the lower-level API call method directly.
                // Assuming c.llmService is *HTTPLLMService (might need type assertion)
                <span class="cov0" title="0">httpService, ok := c.llmService.(*HTTPLLMService)
                if !ok </span><span class="cov0" title="0">{
                        log.Printf("[LLM] ArticleID %d | Model %s | PromptHash %s | LLM service is not *HTTPLLMService", articleID, modelName, promptHash)
                        return 0, "", 0, "", fmt.Errorf("LLM service is not *HTTPLLMService")
                }</span>

                // Call the underlying API method
                <span class="cov0" title="0">apiResp, err := httpService.callLLMAPIWithKey(modelName, prompt, httpService.apiKey) // Use renamed function and pass primary key
                if err != nil </span><span class="cov0" title="0">{
                        // Error is already logged within callLLMAPI
                        lastErr = err
                        // Try to get raw response body even on error for logging/parsing attempts
                        if apiResp != nil </span><span class="cov0" title="0">{
                                rawResp = apiResp.String()
                        }</span>
                        <span class="cov0" title="0">continue</span> // Retry
                }
                <span class="cov0" title="0">rawResp = apiResp.String() // Store raw response on success

                // --- BEGIN INSERTED: Check for embedded error structure ---
                var genericResponse map[string]interface{}
                if errUnmarshal := json.Unmarshal([]byte(rawResp), &amp;genericResponse); errUnmarshal == nil </span><span class="cov0" title="0">{
                        if errorField, ok := genericResponse["error"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if message, msgOK := errorField["message"].(string); msgOK &amp;&amp; message != "" </span><span class="cov0" title="0">{
                                        errType, _ := errorField["type"].(string)
                                        codeVal := errorField["code"]
                                        isRateLimit := strings.Contains(strings.ToLower(message), "rate limit exceeded") || fmt.Sprintf("%v", codeVal) == "429"

                                        if isRateLimit </span><span class="cov0" title="0">{
                                                log.Printf("[LLM] ArticleID %d | Model %s | PromptHash %s | Detected embedded rate limit: %s", articleID, modelName, promptHash, message)
                                                lastErr = ErrBothLLMKeysRateLimited // Use sentinel error
                                        }</span> else<span class="cov0" title="0"> {
                                                log.Printf("[LLM] ArticleID %d | Model %s | PromptHash %s | Detected embedded API error: %s", articleID, modelName, promptHash, message)
                                                lastErr = fmt.Errorf("API error: %s (type: %s, code: %v)", message, errType, codeVal)
                                        }</span>
                                        <span class="cov0" title="0">continue</span> // Skip parsing, retry loop
                                }
                        }
                }
                // --- END INSERTED: Check for embedded error structure ---

                <span class="cov0" title="0">var parseErr error
                // Use the renamed parser for nested JSON expected in this ensemble context
                score, explanation, confidence, parseErr = parseNestedLLMJSONResponse(rawResp)
                if parseErr != nil </span><span class="cov0" title="0">{
                        rawSnippet := rawResp
                        if len(rawSnippet) &gt; 200 </span><span class="cov0" title="0">{
                                rawSnippet = rawSnippet[:200] + "..."
                        }</span>
                        <span class="cov0" title="0">log.Printf("[LLM] ArticleID %d | Model %s | PromptHash %s | Parse error: %v | Raw response: %s", articleID, modelName, promptHash, parseErr, rawSnippet)
                        if articleID == 133 </span><span class="cov0" title="0">{
                                log.Printf("[DEBUG][Article 133] Parse error: %v", parseErr)
                                log.Printf("[DEBUG][Article 133] FULL raw response:\n%s", rawResp)
                        }</span>
                        <span class="cov0" title="0">lastErr = parseErr
                        continue</span>
                }

                // Validate parsed values
                <span class="cov0" title="0">if confidence == 0 </span><span class="cov0" title="0">{
                        log.Printf("[LLM] ArticleID %d | Model %s | PromptHash %s | Invalid zero confidence, retrying...", articleID, modelName, promptHash)
                        lastErr = fmt.Errorf("invalid zero confidence")
                        continue</span>
                }

                <span class="cov0" title="0">log.Printf("[LLM] ArticleID %d | Model %s | PromptHash %s | Success | Score: %.3f | Confidence: %.3f", articleID, modelName, promptHash, score, confidence)
                return score, explanation, confidence, rawResp, nil</span>
        }

        <span class="cov0" title="0">log.Printf("[LLM] ArticleID %d | Model %s | Final failure after retries. Last error: %v", articleID, modelName, lastErr)
        return 0, "", 0, rawResp, lastErr</span>
}

// Removed callOpenAIAPI as it's replaced by direct use of httpService.callLLMAPI

// parseNestedLLMJSONResponse extracts score, explanation, confidence from a raw response
// where the LLM is expected to return a JSON string *within* the main content field
// (e.g., {"choices":[{"message":{"content":"{\"score\":...}"}}]}), or in text format
// with patterns like "Score: X.X" and "Confidence: X.X".
func parseNestedLLMJSONResponse(rawResp string) (float64, string, float64, error) <span class="cov8" title="1">{
        // Step 1: Parse the OpenAI API response JSON
        var apiResp struct {
                Choices []struct {
                        Message struct {
                                Content string `json:"content"`
                        } `json:"message"`
                } `json:"choices"`
        }
        err := json.Unmarshal([]byte(rawResp), &amp;apiResp)
        if err != nil </span><span class="cov8" title="1">{
                return 0, "", 0, fmt.Errorf("error parsing outer LLM API response JSON: %w", err)
        }</span>
        <span class="cov8" title="1">if len(apiResp.Choices) == 0 </span><span class="cov8" title="1">{
                return 0, "", 0, fmt.Errorf("no choices in outer LLM API response")
        }</span>

        // Step 2: Extract the content string
        <span class="cov8" title="1">contentStr := apiResp.Choices[0].Message.Content

        // Step 3: First try to parse as JSON
        // Try JSON format first (with or without backticks)
        var innerResp struct {
                Score       float64 `json:"score"`
                Explanation string  `json:"explanation"`
                Confidence  float64 `json:"confidence"`
        }

        // Add robust backtick stripping
        re := regexp.MustCompile("(?s)```(?:json)?\\s*(.*?)\\s*```") // Matches ```json ... ``` or ``` ... ```
        matches := re.FindStringSubmatch(contentStr)
        if len(matches) &gt;= 2 </span><span class="cov8" title="1">{
                contentStr = strings.TrimSpace(matches[1]) // Use the captured group
        }</span>

        // Try to parse as JSON
        <span class="cov8" title="1">if err = json.Unmarshal([]byte(contentStr), &amp;innerResp); err == nil </span><span class="cov8" title="1">{
                // Successfully parsed as JSON
                return innerResp.Score, innerResp.Explanation, innerResp.Confidence, nil
        }</span>

        // Step 4: If JSON parsing fails, try to extract values using regex patterns
        // Extract score with regex
        <span class="cov8" title="1">scoreRegex := regexp.MustCompile(`Score: (-?\d+\.?\d*)`)
        scoreMatches := scoreRegex.FindStringSubmatch(contentStr)
        if len(scoreMatches) &lt; 2 </span><span class="cov8" title="1">{
                return 0, "", 0, fmt.Errorf("error parsing inner content JSON: %w", err)
        }</span>
        <span class="cov8" title="1">score, err := strconv.ParseFloat(scoreMatches[1], 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", 0, fmt.Errorf("invalid score format: %w", err)
        }</span>

        // Extract confidence with regex
        <span class="cov8" title="1">confidenceRegex := regexp.MustCompile(`Confidence: (\d+\.?\d*)`)
        confidenceMatches := confidenceRegex.FindStringSubmatch(contentStr)
        if len(confidenceMatches) &lt; 2 </span><span class="cov0" title="0">{
                // Default confidence if not found
                return score, "Extracted from text response", 0.5, nil
        }</span>
        <span class="cov8" title="1">confidence, err := strconv.ParseFloat(confidenceMatches[1], 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", 0, fmt.Errorf("invalid confidence format: %w", err)
        }</span>

        // Extract reasoning or explanation
        <span class="cov8" title="1">explanation := "Extracted from text response"
        reasoningRegex := regexp.MustCompile(`Reasoning: (.+)`)
        reasoningMatches := reasoningRegex.FindStringSubmatch(contentStr)
        if len(reasoningMatches) &gt;= 2 </span><span class="cov8" title="1">{
                explanation = reasoningMatches[1]
        }</span>

        <span class="cov8" title="1">return score, explanation, confidence, nil</span>
}

// EnsembleAnalyze performs multi-model, multi-prompt ensemble analysis
func (c *LLMClient) EnsembleAnalyze(articleID int64, content string) (*db.LLMScore, error) <span class="cov0" title="0">{
        // Use models defined in the loaded configuration
        if c.config == nil || len(c.config.Models) == 0 </span><span class="cov0" title="0">{
                log.Printf("[Ensemble] ArticleID %d | Error: LLMClient config is nil or has no models defined.", articleID)
                return nil, fmt.Errorf("LLMClient config is nil or has no models defined")
        }</span>
        // Extract model names from the config
        <span class="cov0" title="0">models := make([]string, 0, len(c.config.Models))
        for _, modelCfg := range c.config.Models </span><span class="cov0" title="0">{
                if modelCfg.ModelName == "" </span><span class="cov0" title="0">{
                        log.Printf("[Ensemble] Warning: Skipping model config with empty name (Perspective: %s)", modelCfg.Perspective)
                        continue</span>
                }
                <span class="cov0" title="0">models = append(models, modelCfg.ModelName)</span>
        }
        <span class="cov0" title="0">if len(models) == 0 </span><span class="cov0" title="0">{
                log.Printf("[Ensemble] ArticleID %d | Error: No valid models found in configuration after filtering.", articleID)
                return nil, fmt.Errorf("no valid models found in configuration")
        }</span>
        <span class="cov0" title="0">log.Printf("[Ensemble] ArticleID %d | Using %d models from config: %v", articleID, len(models), models)
        promptVariants := loadPromptVariants()

        type SubResult struct {
                Model         string  `json:"model"`
                PromptVariant string  `json:"prompt_variant"`
                Score         float64 `json:"score"`
                Explanation   string  `json:"explanation"`
                Confidence    float64 `json:"confidence"`
                RawResponse   string  `json:"raw_response"`
        }

        allSubResults := make([]SubResult, 0)
        perModelResults := make(map[string][]SubResult)
        perModelAgg := make(map[string]map[string]float64)

        const minValid = 1
        const maxAttempts = 6
        const confidenceThreshold = 0.5

        for _, model := range models </span><span class="cov0" title="0">{
                validResponses := make([]SubResult, 0, minValid)
                attempts := 0
        outer:
                for attempts &lt; maxAttempts &amp;&amp; len(validResponses) &lt; minValid </span><span class="cov0" title="0">{
                        for _, pv := range promptVariants </span><span class="cov0" title="0">{
                                for retry := 0; retry &lt; 2 &amp;&amp; attempts &lt; maxAttempts &amp;&amp; len(validResponses) &lt; minValid; retry++ </span><span class="cov0" title="0">{
                                        attempts++
                                        score, explanation, confidence, rawResp, err := c.callLLM(articleID, model, pv, content)
                                        if err != nil </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">sub := SubResult{
                                                Model: model, PromptVariant: pv.ID,
                                                Score: score, Explanation: explanation,
                                                Confidence: confidence, RawResponse: rawResp,
                                        }
                                        allSubResults = append(allSubResults, sub)
                                        if confidence &gt;= confidenceThreshold </span><span class="cov0" title="0">{
                                                validResponses = append(validResponses, sub)
                                        }</span>
                                        <span class="cov0" title="0">if len(validResponses) &gt;= minValid || attempts &gt;= maxAttempts </span><span class="cov0" title="0">{
                                                break outer</span>
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">if len(validResponses) == 0 </span><span class="cov0" title="0">{
                        log.Printf("[Ensemble] Model %s: no valid high-confidence responses. Failing ensemble.", model)
                        return nil, fmt.Errorf("ensemble failed: no valid high-confidence responses from model %s", model)
                }</span>

                <span class="cov0" title="0">var sum, weightedSum, sumWeights float64
                for _, r := range validResponses </span><span class="cov0" title="0">{
                        sum += r.Score
                        weightedSum += r.Score * r.Confidence
                        sumWeights += r.Confidence
                }</span>
                <span class="cov0" title="0">mean := sum / float64(len(validResponses))
                weightedMean := weightedSum / math.Max(sumWeights, 1e-6)

                var varianceSum float64
                for _, r := range validResponses </span><span class="cov0" title="0">{
                        diff := r.Score - mean
                        varianceSum += diff * diff
                }</span>
                <span class="cov0" title="0">variance := varianceSum / float64(len(validResponses))

                perModelResults[model] = validResponses
                perModelAgg[model] = map[string]float64{
                        "mean":          mean,
                        "weighted_mean": weightedMean,
                        "variance":      variance,
                        "count":         float64(len(validResponses)),
                }

                log.Printf("[Ensemble] Model %s: %d valid responses, weighted mean=%.3f, variance=%.3f", model, len(validResponses), weightedMean, variance)</span>
        }

        <span class="cov0" title="0">if len(perModelAgg) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid LLM responses from any model")
        }</span>

        // Aggregate across models
        <span class="cov0" title="0">var totalWeightedSum, totalSumWeights float64
        for _, agg := range perModelAgg </span><span class="cov0" title="0">{
                weight := agg["count"] // or customize per model
                totalWeightedSum += agg["weighted_mean"] * weight
                totalSumWeights += weight
        }</span>
        <span class="cov0" title="0">finalScore := totalWeightedSum / math.Max(totalSumWeights, 1e-6)

        // Compute overall variance (average of per-model variances weighted by count)
        var totalVariance float64
        for _, agg := range perModelAgg </span><span class="cov0" title="0">{
                totalVariance += agg["variance"] * agg["count"]
        }</span>
        <span class="cov0" title="0">totalVariance /= math.Max(totalSumWeights, 1e-6)

        uncertaintyFlag := totalVariance &gt; 0.1 || (totalSumWeights/float64(len(perModelAgg)*minValid) &lt; 0.5)

        meta := map[string]interface{}{
                "all_sub_results":       allSubResults,
                "per_model_results":     perModelResults,
                "per_model_aggregation": perModelAgg,
                "final_aggregation": map[string]interface{}{
                        "weighted_mean":    finalScore,
                        "variance":         totalVariance,
                        "uncertainty_flag": uncertaintyFlag,
                },
                "timestamp": time.Now().Format(time.RFC3339),
        }
        metaBytes, _ := json.Marshal(meta)

        return &amp;db.LLMScore{
                Model:     "ensemble",
                Score:     finalScore,
                Metadata:  string(metaBytes),
                CreatedAt: time.Now(),
        }, nil</span>
}

const promptScaleFragment = "on a scale from -1.0 (strongly left) to 1.0 (strongly right). Respond with a JSON object containing 'score', "
const promptJsonFieldsFragment = "'explanation', and 'confidence'."

// loadPromptVariants returns hardcoded prompt variants (replace with config later)
func loadPromptVariants() []PromptVariant <span class="cov0" title="0">{
        return []PromptVariant{
                {
                        ID: "default",
                        Template: "Please analyze the political bias of the following article on a scale from -1.0 (strongly left) " +
                                "to 1.0 (strongly right). Respond ONLY with a valid JSON object containing 'score', 'explanation', and 'confidence'. Do not include any other text or formatting.",
                        Examples: []string{
                                `{"score": -1.0, "explanation": "Strongly left-leaning language", "confidence": 0.9}`,
                                `{"score": 0.0, "explanation": "Neutral reporting", "confidence": 0.95}`,
                                `{"score": 1.0, "explanation": "Strongly right-leaning language", "confidence": 0.9}`,
                        },
                },
                {
                        ID: "left_focus",
                        Template: "From a progressive or left-leaning perspective, analyze the political bias of the following article " +
                                promptScaleFragment +
                                promptJsonFieldsFragment + "\nRespond ONLY with a valid JSON object containing 'score', 'explanation', and 'confidence'. Do not include any other text or formatting.",
                        Examples: []string{
                                `{"score": -1.0, "explanation": "Strongly aligns with progressive viewpoints", "confidence": 0.9}`,
                                `{"score": 0.0, "explanation": "Balanced or neutral reporting", "confidence": 0.95}`,
                                `{"score": 1.0, "explanation": "Strongly opposes progressive viewpoints", "confidence": 0.9}`,
                        },
                },
                {
                        ID: "center_focus",
                        Template: "From a centrist or neutral perspective, analyze the political bias of the following article " +
                                promptScaleFragment +
                                promptJsonFieldsFragment + "\nRespond ONLY with a valid JSON object containing 'score', 'explanation', and 'confidence'. Do not include any other text or formatting.",
                        Examples: []string{
                                `{"score": -1.0, "explanation": "Clearly favors left-leaning positions", "confidence": 0.9}`,
                                `{"score": 0.0, "explanation": "Appears balanced without clear bias", "confidence": 0.95}`,
                                `{"score": 1.0, "explanation": "Clearly favors right-leaning positions", "confidence": 0.9}`,
                        },
                },
                {
                        ID: "right_focus",
                        Template: "From a conservative or right-leaning perspective, analyze the political bias of the following article " +
                                promptScaleFragment +
                                promptJsonFieldsFragment + "\nRespond ONLY with a valid JSON object containing 'score', 'explanation', and 'confidence'. Do not include any other text or formatting.",
                        Examples: []string{
                                `{"score": -1.0, "explanation": "Strongly opposes conservative viewpoints", "confidence": 0.9}`,
                                `{"score": 0.0, "explanation": "Balanced or neutral reporting", "confidence": 0.95}`,
                                `{"score": 1.0, "explanation": "Strongly aligns with conservative viewpoints", "confidence": 0.9}`,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package llm

import (
        "context"
        "crypto/sha256"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "net/http"
        "os"
        "sort"
        "strings"
        "time"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/apperrors"
        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
        "github.com/go-resty/resty/v2"
        "github.com/jmoiron/sqlx"
)

// ErrInvalidLLMResponse represents an invalid response from LLM service
var ErrInvalidLLMResponse = apperrors.New("Invalid response from LLM service", "llm_service_error")

// HTTP timeout for LLM requests
const defaultLLMTimeout = 30 * time.Second

const (
        LabelUnknown = "unknown"
        LabelLeft    = "left"
        LabelRight   = "right"
        LabelNeutral = "neutral"
)

// compositeScoreConfig holds test override when len(Models)==0
var compositeScoreConfig *CompositeScoreConfig

type ModelConfig struct {
        Perspective string `json:"perspective"`
        ModelName   string `json:"modelName"`
        URL         string `json:"url"`
}

type CompositeScoreConfig struct {
        Formula          string             `json:"formula"`
        Weights          map[string]float64 `json:"weights"`
        MinScore         float64            `json:"min_score"`
        MaxScore         float64            `json:"max_score"`
        DefaultMissing   float64            `json:"default_missing"`
        HandleInvalid    string             `json:"handle_invalid"`
        ConfidenceMethod string             `json:"confidence_method"`
        MinConfidence    float64            `json:"min_confidence"`
        MaxConfidence    float64            `json:"max_confidence"`
        Models           []ModelConfig      `json:"models"`
}

// PromptVariant defines a prompt template with few-shot examples
type PromptVariant struct {
        ID       string
        Template string
        Examples []string
        Model    string // Model name for this variant
        URL      string // API endpoint URL
}

// GeneratePrompt formats the prompt template with content
func (pv *PromptVariant) FormatPrompt(content string) string <span class="cov8" title="1">{
        examplesText := strings.Join(pv.Examples, "\n")
        return fmt.Sprintf("%s\n%s\nArticle:\n%s", pv.Template, examplesText, content)
}</span>

// DefaultPromptVariant is the standard prompt template for analyzing articles
var DefaultPromptVariant = PromptVariant{
        ID: "default",
        Template: "Please analyze the political bias of the following article on a scale from -1.0 (strongly left) " +
                "to 1.0 (strongly right). Respond ONLY with a valid JSON object containing 'score', 'explanation', and 'confidence'. Do not include any other text or formatting.",
        Examples: []string{
                `{"score": -1.0, "explanation": "Strongly left-leaning language", "confidence": 0.9}`,
                `{"score": 0.0, "explanation": "Neutral reporting", "confidence": 0.95}`,
                `{"score": 1.0, "explanation": "Strongly right-leaning language", "confidence": 0.9}`,
        },
}

// Returns (compositeScore, confidence, error)
func ComputeCompositeScoreWithConfidence(scores []db.LLMScore) (float64, float64, error) <span class="cov8" title="1">{
        // Use override config in tests if provided, else use built-in defaults
        var cfg *CompositeScoreConfig
        if compositeScoreConfig != nil </span><span class="cov8" title="1">{
                cfg = compositeScoreConfig
                // clear override for next invocation
                compositeScoreConfig = nil
        }</span> else<span class="cov8" title="1"> {
                cfg = &amp;CompositeScoreConfig{
                        Formula:          "average",
                        Weights:          map[string]float64{"left": 1.0, "center": 1.0, "right": 1.0},
                        MinScore:         -1.0,
                        MaxScore:         1.0,
                        DefaultMissing:   0.0,
                        HandleInvalid:    "default",
                        ConfidenceMethod: "count_valid",
                }
        }</span>

        // Map scores to perspectives
        <span class="cov8" title="1">scoreMap := map[string]float64{"left": cfg.DefaultMissing, "center": cfg.DefaultMissing, "right": cfg.DefaultMissing}
        validModels := make(map[string]bool)
        sumScores := 0.0
        sumWeights := 0.0
        for _, s := range scores </span><span class="cov8" title="1">{
                model := strings.ToLower(s.Model)
                var perspective string
                switch model </span>{
                case "left":<span class="cov8" title="1">
                        perspective = "left"</span>
                case "center":<span class="cov8" title="1">
                        perspective = "center"</span>
                case "right":<span class="cov8" title="1">
                        perspective = "right"</span>
                default:<span class="cov8" title="1">
                        continue</span>
                }
                <span class="cov8" title="1">val := s.Score
                if cfg.HandleInvalid == "ignore" &amp;&amp; (isInvalid(val) || val &lt; cfg.MinScore || val &gt; cfg.MaxScore) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if isInvalid(val) || val &lt; cfg.MinScore || val &gt; cfg.MaxScore </span><span class="cov8" title="1">{
                        val = cfg.DefaultMissing
                }</span>
                <span class="cov8" title="1">w := 1.0
                if cfg.Formula == "weighted" </span><span class="cov8" title="1">{
                        if weight, ok := cfg.Weights[perspective]; ok </span><span class="cov8" title="1">{
                                w = weight
                        }</span>
                }
                <span class="cov8" title="1">scoreMap[perspective] = val
                sumScores += val * w
                sumWeights += w
                validModels[perspective] = true</span>
        }
        // Compute composite
        <span class="cov8" title="1">var composite float64
        switch cfg.Formula </span>{
        case "weighted":<span class="cov8" title="1">
                if sumWeights &gt; 0 </span><span class="cov8" title="1">{
                        composite = sumScores / sumWeights
                }</span>
        default:<span class="cov8" title="1"> // average and others: simple average over three perspectives
                composite = (scoreMap["left"] + scoreMap["center"] + scoreMap["right"]) / 3.0</span>
        }
        // Compute confidence
        <span class="cov8" title="1">var confidence float64
        switch cfg.ConfidenceMethod </span>{
        case "count_valid":<span class="cov8" title="1">
                confidence = float64(len(validModels)) / 3.0</span>
        case "spread":<span class="cov8" title="1">
                // normalize spread across configured score range
                span := cfg.MaxScore - cfg.MinScore
                if span &gt; 0 </span><span class="cov8" title="1">{
                        // difference between max and min perspective scores
                        vals := []float64{scoreMap["left"], scoreMap["center"], scoreMap["right"]}
                        sort.Float64s(vals)
                        confidence = (vals[2] - vals[0]) / span
                }</span>
        default:<span class="cov0" title="0">
                confidence = float64(len(validModels)) / 3.0</span>
        }
        <span class="cov8" title="1">return composite, confidence, nil</span>
}

func ComputeCompositeScore(scores []db.LLMScore) float64 <span class="cov8" title="1">{
        score, _, _ := ComputeCompositeScoreWithConfidence(scores)
        return score
}</span>

func isInvalid(f float64) bool <span class="cov8" title="1">{
        return (f != f) || (f &gt; 1e10) || (f &lt; -1e10)
}</span>

func parseLLMAPIResponse(body []byte) (string, error) <span class="cov8" title="1">{
        var directResponse struct {
                Text   string `json:"text"`
                Result string `json:"result"`
                Output string `json:"output"`
        }

        if err := json.Unmarshal(body, &amp;directResponse); err == nil </span><span class="cov8" title="1">{
                if directResponse.Text != "" </span><span class="cov0" title="0">{
                        return directResponse.Text, nil
                }</span>
                <span class="cov8" title="1">if directResponse.Result != "" </span><span class="cov0" title="0">{
                        return directResponse.Result, nil
                }</span>
                <span class="cov8" title="1">if directResponse.Output != "" </span><span class="cov0" title="0">{
                        return directResponse.Output, nil
                }</span>
        }

        <span class="cov8" title="1">var genericResponse map[string]interface{}
        if err := json.Unmarshal(body, &amp;genericResponse); err == nil </span><span class="cov8" title="1">{
                if errorField, ok := genericResponse["error"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if message, ok := errorField["message"].(string); ok </span><span class="cov8" title="1">{
                                errType := errorField["type"]
                                errCode := errorField["code"]
                                if strings.Contains(strings.ToLower(message), "rate limit") </span><span class="cov0" title="0">{
                                        return "", ErrBothLLMKeysRateLimited
                                }</span>
                                <span class="cov8" title="1">return "", apperrors.HandleError(
                                        fmt.Errorf("API error: %s (type: %v, code: %v)", message, errType, errCode),
                                        "LLM service error response",
                                )</span>
                        }
                }
        }

        <span class="cov0" title="0">var standardResp struct {
                Choices []struct {
                        Message struct {
                                Content string `json:"content"`
                        } `json:"message"`
                } `json:"choices"`
        }

        if err := json.Unmarshal(body, &amp;standardResp); err != nil </span><span class="cov0" title="0">{
                return "", apperrors.HandleError(err, "failed to parse LLM response")
        }</span>

        <span class="cov0" title="0">if len(standardResp.Choices) == 0 || standardResp.Choices[0].Message.Content == "" </span><span class="cov0" title="0">{
                return "", ErrInvalidLLMResponse
        }</span>

        <span class="cov0" title="0">return standardResp.Choices[0].Message.Content, nil</span>
}

// LLMClient provides methods to analyze articles using language models
type LLMClient struct {
        client     *http.Client
        cache      *Cache
        db         *sqlx.DB
        llmService LLMService
        config     *CompositeScoreConfig
}

// ArticleAnalysis represents the full analysis results for an article
type ArticleAnalysis struct {
        ArticleID       int64                  `json:"article_id"`
        Scores          []db.LLMScore          `json:"scores"`
        CompositeScore  float64                `json:"composite_score"`
        Confidence      float64                `json:"confidence"`
        CategoryScores  map[string]float64     `json:"category_scores"`
        DetailedResults map[string]interface{} `json:"detailed_results"`
        CreatedAt       time.Time              `json:"created_at"`
}

func (c *LLMClient) SetHTTPLLMTimeout(timeout time.Duration) <span class="cov0" title="0">{
        httpService, ok := c.llmService.(*HTTPLLMService)
        if ok &amp;&amp; httpService != nil &amp;&amp; httpService.client != nil </span><span class="cov0" title="0">{
                httpService.client.SetTimeout(timeout)
        }</span>
}

func NewLLMClient(dbConn *sqlx.DB) *LLMClient <span class="cov8" title="1">{
        cache := NewCache()

        // Get OpenRouter configuration
        primaryKey := os.Getenv("LLM_API_KEY")
        backupKey := os.Getenv("LLM_API_KEY_SECONDARY")
        baseURL := os.Getenv("LLM_BASE_URL")

        // Replace fatal exit with panic for missing primary key to satisfy tests
        if primaryKey == "" </span><span class="cov8" title="1">{
                panic("ERROR: LLM_API_KEY not set")</span>
        }

        <span class="cov8" title="1">config := &amp;CompositeScoreConfig{
                Formula:          "average",
                Weights:          map[string]float64{"left": 1.0, "center": 1.0, "right": 1.0},
                MinScore:         -1e10,
                MaxScore:         1e10,
                DefaultMissing:   0.0,
                HandleInvalid:    "default",
                ConfidenceMethod: "count_valid",
                MinConfidence:    0.0,
                MaxConfidence:    1.0,
        }

        // Create resty client with timeout
        restyClient := resty.New()
        restyClient.SetTimeout(defaultLLMTimeout)

        // Initialize service with OpenRouter configuration
        service := NewHTTPLLMService(restyClient, primaryKey, backupKey, baseURL)

        return &amp;LLMClient{
                client:     &amp;http.Client{},
                cache:      cache,
                db:         dbConn,
                llmService: service,
                config:     config,
        }</span>
}

func (c *LLMClient) analyzeContent(articleID int64, content string, model string) (*db.LLMScore, error) <span class="cov0" title="0">{
        log.Printf("[analyzeContent] Entry: articleID=%d, model=%s", articleID, model)
        contentHash := hashContent(content)

        if cached, ok := c.cache.Get(contentHash, model); ok </span><span class="cov0" title="0">{
                return cached, nil
        }</span>

        <span class="cov0" title="0">var err error

        generalPrompt := PromptVariant{
                ID: "default",
                Template: "Please analyze the political bias of the following article on a scale from -1.0 (strongly left) " +
                        "to 1.0 (strongly right). Respond ONLY with a valid JSON object containing 'score', 'explanation', and 'confidence'. Do not include any other text or formatting.",
                Examples: []string{
                        `{"score": -1.0, "explanation": "Strongly left-leaning language", "confidence": 0.9}`,
                        `{"score": 0.0, "explanation": "Neutral reporting", "confidence": 0.95}`,
                        `{"score": 1.0, "explanation": "Strongly right-leaning language", "confidence": 0.9}`,
                },
        }

        scoreVal, explanation, confidence, _, err := c.callLLM(articleID, model, generalPrompt, content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">meta := fmt.Sprintf(`{"explanation": %q, "confidence": %.3f}`, explanation, confidence)

        score := &amp;db.LLMScore{
                ArticleID: articleID,
                Model:     model,
                Score:     scoreVal,
                Metadata:  meta,
                CreatedAt: time.Now(),
        }

        c.cache.Set(contentHash, model, score)

        return score, nil</span>
}

func (c *LLMClient) ProcessUnscoredArticles() error <span class="cov0" title="0">{
        query := `
        SELECT a.* FROM articles a
        WHERE NOT EXISTS (
                SELECT 1 FROM llm_scores s
                WHERE s.article_id = a.id
        )
        `
        var articles []db.Article
        if err := c.db.Select(&amp;articles, query); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, article := range articles </span><span class="cov0" title="0">{
                if err := c.AnalyzeAndStore(&amp;article); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to analyze article ID %d: %v", article.ID, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *LLMClient) AnalyzeAndStore(article *db.Article) error <span class="cov0" title="0">{
        cfg := &amp;CompositeScoreConfig{
                Formula:          "average",
                Weights:          map[string]float64{"left": 1.0, "center": 1.0, "right": 1.0},
                MinScore:         -1e10,
                MaxScore:         1e10,
                DefaultMissing:   0.0,
                HandleInvalid:    "default",
                ConfidenceMethod: "count_valid",
                MinConfidence:    0.0,
                MaxConfidence:    1.0,
        }

        for _, m := range cfg.Models </span><span class="cov0" title="0">{
                log.Printf("[DEBUG][AnalyzeAndStore] Article %d | Perspective: %s | ModelName passed: %s | URL: %s", article.ID, m.Perspective, m.ModelName, m.URL)
                score, err := c.analyzeContent(article.ID, article.Content, m.ModelName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error analyzing article %d with model %s: %v", article.ID, m.ModelName, err)

                        continue</span>
                }

                <span class="cov0" title="0">_, err = db.InsertLLMScore(c.db, score)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error inserting LLM score for article %d model %s: %v", article.ID, m.ModelName, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *LLMClient) ReanalyzeArticle(articleID int64) error <span class="cov0" title="0">{
        log.Printf("[ReanalyzeArticle %d] Starting reanalysis", articleID)
        tx, err := c.db.Beginx()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.Printf("[ReanalyzeArticle %d] Deleting existing scores", articleID)
        _, err = tx.Exec("DELETE FROM llm_scores WHERE article_id = ?", articleID)
        if err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                        log.Printf("tx.Rollback() failed: %v", rbErr)
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">var article db.Article

        log.Printf("[ReanalyzeArticle %d] Fetching article data", articleID)
        err = tx.Get(&amp;article, "SELECT * FROM articles WHERE id = ?", articleID)
        if err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                        log.Printf("tx.Rollback() failed: %v", rbErr)
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">log.Printf("[ReanalyzeArticle %d] Fetched article: Title='%.50s'", articleID, article.Title)
        log.Printf("[ReanalyzeArticle %d] Starting analysis loop for models", articleID)
        for _, m := range compositeScoreConfig.Models </span><span class="cov0" title="0">{
                log.Printf("[ReanalyzeArticle %d] Calling analyzeContent for model: %s", articleID, m.ModelName)
                score, err := c.analyzeContent(article.ID, article.Content, m.ModelName)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ReanalyzeArticle %d] Error from analyzeContent for %s: %v", articleID, m.ModelName, err)
                        continue</span>
                }
                <span class="cov0" title="0">log.Printf("[ReanalyzeArticle %d] analyzeContent successful for: %s. Score: %.2f", articleID, m.ModelName, score.Score)

                _, err = tx.NamedExec(`INSERT INTO llm_scores (article_id, model, score, metadata)
                        VALUES (:article_id, :model, :score, :metadata)`, score)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("[ReanalyzeArticle %d] Error inserting score for %s: %v", articleID, m.ModelName, err)
                }</span> else<span class="cov0" title="0"> {
                        log.Printf("[ReanalyzeArticle %d] Successfully inserted score for: %s", articleID, m.ModelName)
                }</span>
        }

        <span class="cov0" title="0">scores, err := c.FetchScores(article.ID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ReanalyzeArticle %d] Error fetching scores: %v", articleID, err)
                return fmt.Errorf("failed to fetch scores for ensemble calculation: %w", err)
        }</span>

        <span class="cov0" title="0">finalScore, confidence, err := ComputeCompositeScoreWithConfidence(scores)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ReanalyzeArticle %d] Error computing composite score: %v", articleID, err)
                return fmt.Errorf("failed to compute composite score: %w", err)
        }</span>

        <span class="cov0" title="0">meta := map[string]interface{}{
                "timestamp": time.Now().Format(time.RFC3339),
                "final_aggregation": map[string]interface{}{
                        "weighted_mean": finalScore,
                        "variance":      1.0 - confidence,
                },
        }
        metaBytes, _ := json.Marshal(meta)

        ensembleScore := &amp;db.LLMScore{
                ArticleID: article.ID,
                Model:     "ensemble",
                Score:     finalScore,
                Metadata:  string(metaBytes),
                CreatedAt: time.Now(),
        }

        _, err = tx.NamedExec(`INSERT INTO llm_scores (article_id, model, score, metadata, created_at)
                VALUES (:article_id, :model, :score, :metadata, :created_at)`, ensembleScore)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ReanalyzeArticle %d] Error inserting ensemble score: %v", articleID, err)
                return fmt.Errorf("failed to insert ensemble score: %w", err)
        }</span>

        <span class="cov0" title="0">err = db.UpdateArticleScore(c.db, article.ID, finalScore, confidence)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[ReanalyzeArticle %d] Error updating article score: %v", articleID, err)
                return fmt.Errorf("failed to update article score: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("[ReanalyzeArticle %d] Successfully completed reanalysis with score: %.2f, confidence: %.2f",
                articleID, finalScore, confidence)
        return nil</span>
}

func (c *LLMClient) AnalyzeContent(articleID int64, content string, model string, url string) (*db.LLMScore, error) <span class="cov0" title="0">{
        return c.analyzeContent(articleID, content, model)
}</span>

func (c *LLMClient) GetArticle(articleID int64) (db.Article, error) <span class="cov0" title="0">{
        var article db.Article
        err := c.db.Get(&amp;article, "SELECT * FROM articles WHERE id = ?", articleID)
        return article, err
}</span>

func (c *LLMClient) DeleteScores(articleID int64) error <span class="cov0" title="0">{
        _, err := c.db.Exec("DELETE FROM llm_scores WHERE article_id = ?", articleID)
        return err
}</span>

func (c *LLMClient) FetchScores(articleID int64) ([]db.LLMScore, error) <span class="cov0" title="0">{
        return db.FetchLLMScores(c.db, articleID)
}</span>

// ScoreWithModel uses a single model to score content
func (c *LLMClient) ScoreWithModel(article *db.Article, modelName string) (float64, error) <span class="cov8" title="1">{
        // Create a prompt variant with the specified model
        promptVariant := DefaultPromptVariant
        promptVariant.Model = modelName

        // Use the LLM service directly to handle rate limiting properly
        score, _, err := c.llmService.ScoreContent(context.Background(), promptVariant, article)

        if err != nil </span><span class="cov8" title="1">{
                // Specifically check for rate limit errors first
                if errors.Is(err, ErrBothLLMKeysRateLimited) </span><span class="cov8" title="1">{
                        return 0, ErrBothLLMKeysRateLimited
                }</span>

                // Check for service unavailable
                <span class="cov8" title="1">if strings.Contains(strings.ToLower(err.Error()), "503") ||
                        strings.Contains(strings.ToLower(err.Error()), "service unavailable") </span><span class="cov8" title="1">{
                        return 0, apperrors.New("LLM service unavailable", "llm_service_error")
                }</span>

                // For any other errors, return a more descriptive error with llm_service_error code
                <span class="cov8" title="1">return 0, apperrors.Wrap(err, "llm_service_error", fmt.Sprintf("scoring with model %s failed", modelName))</span>
        }

        <span class="cov8" title="1">return score, nil</span>
}

func (c *LLMClient) StoreEnsembleScore(article *db.Article) (float64, error) <span class="cov0" title="0">{
        scores, err := c.FetchScores(article.ID)
        if err != nil </span><span class="cov0" title="0">{
                return 0.0, fmt.Errorf("failed to fetch scores for ensemble calculation: %w", err)
        }</span>

        <span class="cov0" title="0">finalScore, confidence, err := ComputeCompositeScoreWithConfidence(scores)
        if err != nil </span><span class="cov0" title="0">{
                return 0.0, fmt.Errorf("failed to compute composite score: %w", err)
        }</span>

        <span class="cov0" title="0">meta := map[string]interface{}{
                "timestamp": time.Now().Format(time.RFC3339),
                "final_aggregation": map[string]interface{}{
                        "weighted_mean": finalScore,
                        "variance":      1.0 - confidence,
                },
        }
        metaBytes, _ := json.Marshal(meta)

        ensembleScore := &amp;db.LLMScore{
                ArticleID: article.ID,
                Model:     "ensemble",
                Score:     finalScore,
                Metadata:  string(metaBytes),
                CreatedAt: time.Now(),
        }

        _, err = c.db.NamedExec(`INSERT INTO llm_scores (article_id, model, score, metadata, created_at)
                VALUES (:article_id, :model, :score, :metadata, :created_at)`, ensembleScore)
        if err != nil </span><span class="cov0" title="0">{
                return finalScore, fmt.Errorf("failed to insert ensemble score: %w", err)
        }</span>

        <span class="cov0" title="0">updateErr := db.UpdateArticleScore(c.db, article.ID, finalScore, confidence)
        if updateErr != nil </span><span class="cov0" title="0">{
                return finalScore, fmt.Errorf("failed to update article score: %w", updateErr)
        }</span>

        <span class="cov0" title="0">return finalScore, nil</span>
}

func hashContent(content string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(content))
        return fmt.Sprintf("%x", hash)
}</span>

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package llm

import (
        "sync"
        "time"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/models"
)

// ProgressManager tracks scoring progress with cleanup
type ProgressManager struct {
        progressMap     map[int64]*models.ProgressState
        progressMapLock sync.RWMutex
        cleanupInterval time.Duration
}

// NewProgressManager creates a progress manager with cleanup
func NewProgressManager(cleanupInterval time.Duration) *ProgressManager <span class="cov8" title="1">{
        pm := &amp;ProgressManager{
                progressMap:     make(map[int64]*models.ProgressState),
                cleanupInterval: cleanupInterval,
        }
        go pm.startCleanupRoutine()
        return pm
}</span>

// SetProgress sets the progress state for an article
func (pm *ProgressManager) SetProgress(articleID int64, state *models.ProgressState) <span class="cov8" title="1">{
        pm.progressMapLock.Lock()
        defer pm.progressMapLock.Unlock()
        pm.progressMap[articleID] = state
}</span>

// GetProgress retrieves the progress state for an article
func (pm *ProgressManager) GetProgress(articleID int64) *models.ProgressState <span class="cov8" title="1">{
        pm.progressMapLock.RLock()
        defer pm.progressMapLock.RUnlock()
        return pm.progressMap[articleID]
}</span>

// startCleanupRoutine periodically removes stale entries
func (pm *ProgressManager) startCleanupRoutine() <span class="cov8" title="1">{
        ticker := time.NewTicker(pm.cleanupInterval)
        defer ticker.Stop()
        for range ticker.C </span><span class="cov0" title="0">{
                pm.cleanup()
        }</span>
}

// cleanup removes completed or stale progress entries
func (pm *ProgressManager) cleanup() <span class="cov8" title="1">{
        pm.progressMapLock.Lock()
        defer pm.progressMapLock.Unlock()
        now := time.Now().Unix()
        for id, progress := range pm.progressMap </span><span class="cov8" title="1">{
                if (progress.Status == "Success" || progress.Status == "Error") &amp;&amp; now-progress.LastUpdated &gt; 300 </span><span class="cov8" title="1">{
                        delete(pm.progressMap, id)
                        continue</span>
                }
                <span class="cov8" title="1">if progress.Status == "InProgress" &amp;&amp; now-progress.LastUpdated &gt; 1800 </span><span class="cov8" title="1">{
                        delete(pm.progressMap, id)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package llm

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
)

var perspectives = []string{"left", "center", "right"}

// ScoreCalculator defines the interface for composite score calculation
// Returns (score, confidence, error)
type ScoreCalculator interface {
        CalculateScore(scores []db.LLMScore) (float64, float64, error)
}

// DefaultScoreCalculator implements ScoreCalculator using the new averaging logic
// It preserves the -1.0 to +1.0 scale and averages confidences from model metadata
// Missing perspectives are treated as 0 for both score and confidence
type DefaultScoreCalculator struct {
        Config *CompositeScoreConfig // Must be provided, not nil
}

// initializeMaps creates and initializes maps for scores and confidence values
func (c *DefaultScoreCalculator) initializeMaps() (map[string]*float64, map[string]*float64) <span class="cov8" title="1">{
        scoreMap := make(map[string]*float64)
        confMap := make(map[string]*float64)
        for _, p := range perspectives </span><span class="cov8" title="1">{
                scoreMap[p] = nil
                confMap[p] = nil
        }</span>
        <span class="cov8" title="1">return scoreMap, confMap</span>
}

// getPerspective determines the perspective (left/center/right) for a given model
func (c *DefaultScoreCalculator) getPerspective(model string) string <span class="cov8" title="1">{
        perspective := MapModelToPerspective(model, c.Config)
        if perspective != "" </span><span class="cov8" title="1">{
                return perspective
        }</span>

        <span class="cov8" title="1">model = strings.ToLower(model)
        switch model </span>{
        case LabelLeft:<span class="cov0" title="0">
                return "left"</span>
        case LabelRight:<span class="cov0" title="0">
                return "right"</span>
        case "center":<span class="cov0" title="0">
                return "center"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// extractConfidence extracts confidence value from score metadata
func (c *DefaultScoreCalculator) extractConfidence(metadata string) float64 <span class="cov8" title="1">{
        var meta map[string]interface{}
        if err := json.Unmarshal([]byte(metadata), &amp;meta); err != nil </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">if conf, ok := meta["confidence"]; ok </span><span class="cov8" title="1">{
                // Handle both float64 and integer confidence values
                switch v := conf.(type) </span>{
                case float64:<span class="cov8" title="1">
                        return v</span>
                case int:<span class="cov0" title="0">
                        return float64(v)</span>
                case int64:<span class="cov0" title="0">
                        return float64(v)</span>
                default:<span class="cov8" title="1">
                        return 0.0</span>
                }
        }
        <span class="cov8" title="1">return 0.0</span>
}

func (c *DefaultScoreCalculator) CalculateScore(scores []db.LLMScore) (float64, float64, error) <span class="cov8" title="1">{
        if c.Config == nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("DefaultScoreCalculator: Config must not be nil")
        }</span>

        <span class="cov8" title="1">scoreMap, confMap := c.initializeMaps()

        // For each perspective, use the last provided score (and its confidence)
        for _, s := range scores </span><span class="cov8" title="1">{
                perspective := c.getPerspective(s.Model)
                if perspective == "" || (perspective != "left" &amp;&amp; perspective != "center" &amp;&amp; perspective != "right") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">val := s.Score
                if isInvalid(val) || val &lt; c.Config.MinScore || val &gt; c.Config.MaxScore </span><span class="cov8" title="1">{
                        // Set out of range scores to 0.0 per test expectations
                        val = 0.0
                }</span>
                <span class="cov8" title="1">scoreMap[perspective] = &amp;val

                conf := c.extractConfidence(s.Metadata)
                confMap[perspective] = &amp;conf</span>
        }

        // Calculate average score and confidence
        <span class="cov8" title="1">validScores := 0
        validConfs := 0
        scoreSum := 0.0
        confSum := 0.0

        for _, p := range perspectives </span><span class="cov8" title="1">{
                if scoreMap[p] != nil </span><span class="cov8" title="1">{
                        scoreSum += *scoreMap[p]
                        validScores++
                }</span>

                <span class="cov8" title="1">if confMap[p] != nil </span><span class="cov8" title="1">{
                        confSum += *confMap[p]
                        validConfs++
                }</span>
        }

        // Calculate averages based on valid values
        <span class="cov8" title="1">var avgScore float64
        var avgConf float64

        if validScores &gt; 0 </span><span class="cov8" title="1">{
                avgScore = scoreSum / float64(validScores)
        }</span>

        <span class="cov8" title="1">if validConfs &gt; 0 </span><span class="cov8" title="1">{
                avgConf = confSum / float64(validConfs)
        }</span>

        <span class="cov8" title="1">return avgScore, avgConf, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package llm

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
        "github.com/alexandru-savinov/BalancedNewsGo/internal/models"
        "github.com/jmoiron/sqlx"
)

// ScoreManager orchestrates score operations and dependencies
// This is a skeleton for the refactor, to be filled in with logic in later steps
type ScoreManager struct {
        db          *sqlx.DB
        cache       *Cache
        calculator  ScoreCalculator
        progressMgr *ProgressManager
}

// NewScoreManager creates a new score manager with dependencies
func NewScoreManager(db *sqlx.DB, cache *Cache, calculator ScoreCalculator, progressMgr *ProgressManager) *ScoreManager <span class="cov8" title="1">{
        return &amp;ScoreManager{
                db:          db,
                cache:       cache,
                calculator:  calculator,
                progressMgr: progressMgr,
        }
}</span>

// UpdateArticleScore handles atomic update of score and confidence
func (sm *ScoreManager) UpdateArticleScore(articleID int64, scores []db.LLMScore, cfg *CompositeScoreConfig) (float64, float64, error) <span class="cov0" title="0">{
        if sm.calculator == nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("ScoreManager: calculator is nil")
        }</span>
        <span class="cov0" title="0">if sm.db == nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("ScoreManager: db is nil")
        }</span>
        <span class="cov0" title="0">if cfg == nil </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("ScoreManager: config is nil")
        }</span>

        // Progress: Start
        <span class="cov0" title="0">if sm.progressMgr != nil </span><span class="cov0" title="0">{
                ps := &amp;models.ProgressState{Step: "Start", Message: "Starting scoring", Percent: 0, Status: "InProgress", LastUpdated: time.Now().Unix()}
                sm.progressMgr.SetProgress(articleID, ps)
        }</span>

        <span class="cov0" title="0">tx, err := sm.db.BeginTxx(context.Background(), nil)
        if err != nil </span><span class="cov0" title="0">{
                if sm.progressMgr != nil </span><span class="cov0" title="0">{
                        ps := &amp;models.ProgressState{Step: "DB Transaction", Message: "Failed to start DB transaction", Percent: 0, Status: "Error", Error: err.Error(), LastUpdated: time.Now().Unix()}
                        sm.progressMgr.SetProgress(articleID, ps)
                }</span>
                <span class="cov0" title="0">return 0, 0, fmt.Errorf("failed to begin transaction: %w", err)</span>
        }
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if p := recover(); p != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Progress: Calculating
        <span class="cov0" title="0">if sm.progressMgr != nil </span><span class="cov0" title="0">{
                ps := &amp;models.ProgressState{Step: "Calculating", Message: "Calculating score", Percent: 20, Status: "InProgress", LastUpdated: time.Now().Unix()}
                sm.progressMgr.SetProgress(articleID, ps)
        }</span>

        <span class="cov0" title="0">score, confidence, calcErr := sm.calculator.CalculateScore(scores)
        if calcErr != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                if sm.progressMgr != nil </span><span class="cov0" title="0">{
                        ps := &amp;models.ProgressState{Step: "Calculation", Message: "Score calculation failed", Percent: 20, Status: "Error", Error: calcErr.Error(), LastUpdated: time.Now().Unix()}
                        sm.progressMgr.SetProgress(articleID, ps)
                }</span>
                <span class="cov0" title="0">return 0, 0, fmt.Errorf("score calculation failed: %w", calcErr)</span>
        }

        // Progress: Storing ensemble score
        <span class="cov0" title="0">if sm.progressMgr != nil </span><span class="cov0" title="0">{
                ps := &amp;models.ProgressState{Step: "Storing", Message: "Storing ensemble score", Percent: 60, Status: "InProgress", LastUpdated: time.Now().Unix()}
                sm.progressMgr.SetProgress(articleID, ps)
        }</span>

        <span class="cov0" title="0">meta := map[string]interface{}{
                "timestamp":   time.Now().Format(time.RFC3339),
                "aggregation": "ensemble",
                "confidence":  confidence,
        }
        metaBytes, _ := json.Marshal(meta)
        ensembleScore := &amp;db.LLMScore{
                ArticleID: articleID,
                Model:     "ensemble",
                Score:     score,
                Metadata:  string(metaBytes),
                CreatedAt: time.Now(),
        }
        _, err = db.InsertLLMScore(tx, ensembleScore)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                if sm.progressMgr != nil </span><span class="cov0" title="0">{
                        ps := &amp;models.ProgressState{Step: "DB Insert", Message: "Failed to insert ensemble score", Percent: 70, Status: "Error", Error: err.Error(), LastUpdated: time.Now().Unix()}
                        sm.progressMgr.SetProgress(articleID, ps)
                }</span>
                <span class="cov0" title="0">return 0, 0, fmt.Errorf("failed to insert ensemble score: %w", err)</span>
        }

        // Progress: Updating article
        <span class="cov0" title="0">if sm.progressMgr != nil </span><span class="cov0" title="0">{
                ps := &amp;models.ProgressState{Step: "Updating", Message: "Updating article score", Percent: 80, Status: "InProgress", LastUpdated: time.Now().Unix()}
                sm.progressMgr.SetProgress(articleID, ps)
        }</span>

        <span class="cov0" title="0">err = db.UpdateArticleScoreLLM(tx, articleID, score, confidence)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                if sm.progressMgr != nil </span><span class="cov0" title="0">{
                        ps := &amp;models.ProgressState{Step: "DB Update", Message: "Failed to update article", Percent: 90, Status: "Error", Error: err.Error(), LastUpdated: time.Now().Unix()}
                        sm.progressMgr.SetProgress(articleID, ps)
                }</span>
                <span class="cov0" title="0">return 0, 0, fmt.Errorf("failed to update article: %w", err)</span>
        }

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                if sm.progressMgr != nil </span><span class="cov0" title="0">{
                        ps := &amp;models.ProgressState{Step: "DB Commit", Message: "Failed to commit transaction", Percent: 95, Status: "Error", Error: err.Error(), LastUpdated: time.Now().Unix()}
                        sm.progressMgr.SetProgress(articleID, ps)
                }</span>
                <span class="cov0" title="0">return 0, 0, fmt.Errorf("failed to commit transaction: %w", err)</span>
        }

        // Progress: Invalidate cache
        <span class="cov0" title="0">if sm.cache != nil </span><span class="cov0" title="0">{
                sm.cache.Delete(fmt.Sprintf("article:%d", articleID))
                sm.cache.Delete(fmt.Sprintf("ensemble:%d", articleID))
                sm.cache.Delete(fmt.Sprintf("bias:%d", articleID))
        }</span>

        // Progress: Success
        <span class="cov0" title="0">if sm.progressMgr != nil </span><span class="cov0" title="0">{
                ps := &amp;models.ProgressState{Step: "Complete", Message: "Scoring complete", Percent: 100, Status: "Success", FinalScore: &amp;score, LastUpdated: time.Now().Unix()}
                sm.progressMgr.SetProgress(articleID, ps)
        }</span>

        <span class="cov0" title="0">return score, confidence, nil</span>
}

// InvalidateScoreCache invalidates all score-related caches for an article
func (sm *ScoreManager) InvalidateScoreCache(articleID int64) <span class="cov8" title="1">{
        if sm.cache == nil </span><span class="cov0" title="0">{
                return
        }</span>
        // Invalidate all relevant cache keys (matching API cache usage)
        <span class="cov8" title="1">keys := []string{
                fmt.Sprintf("article:%d", articleID),
                fmt.Sprintf("ensemble:%d", articleID),
                fmt.Sprintf("bias:%d", articleID),
        }
        for _, key := range keys </span><span class="cov8" title="1">{
                sm.cache.Delete(key)
        }</span>
}

// TrackProgress is a stub for progress tracking
func (sm *ScoreManager) TrackProgress(articleID int64, step, status string) {<span class="cov0" title="0">
        // TODO: Implement progress tracking
}</span>

// SetProgress proxies to ProgressManager
func (sm *ScoreManager) SetProgress(articleID int64, state *models.ProgressState) <span class="cov8" title="1">{
        if sm.progressMgr != nil </span><span class="cov8" title="1">{
                sm.progressMgr.SetProgress(articleID, state)
        }</span>
}

// GetProgress proxies to ProgressManager
func (sm *ScoreManager) GetProgress(articleID int64) *models.ProgressState <span class="cov8" title="1">{
        if sm.progressMgr != nil </span><span class="cov8" title="1">{
                return sm.progressMgr.GetProgress(articleID)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package llm

import (
        "context"
        "fmt"
        "strings"

        "github.com/alexandru-savinov/BalancedNewsGo/internal/db"
        "github.com/go-resty/resty/v2"
)

// LLMService defines the interface for LLM analysis providers
type LLMService interface {
        ScoreContent(ctx context.Context, pv PromptVariant, art *db.Article) (score float64, confidence float64, err error)
}

// HTTPLLMService implements LLMService using HTTP calls
type HTTPLLMService struct {
        client    *resty.Client
        apiKey    string
        backupKey string
        baseURL   string
}

// NewHTTPLLMService creates a new HTTP-based LLM service
func NewHTTPLLMService(c *resty.Client, primaryKey string, backupKey string, baseURL string) *HTTPLLMService <span class="cov8" title="1">{
        if baseURL == "" </span><span class="cov8" title="1">{
                baseURL = "https://openrouter.ai/api/v1"
        }</span>
        // Ensure baseURL ends with /chat/completions
        <span class="cov8" title="1">if !strings.HasSuffix(baseURL, "/chat/completions") </span><span class="cov8" title="1">{
                if strings.HasSuffix(baseURL, "/") </span><span class="cov0" title="0">{
                        baseURL = baseURL + "chat/completions"
                }</span> else<span class="cov8" title="1"> {
                        baseURL = baseURL + "/chat/completions"
                }</span>
        }
        <span class="cov8" title="1">return &amp;HTTPLLMService{
                client:    c,
                apiKey:    primaryKey,
                backupKey: backupKey,
                baseURL:   baseURL,
        }</span>
}

// callLLMAPIWithKey makes a direct API call to the LLM service
func (s *HTTPLLMService) callLLMAPIWithKey(modelName string, prompt string, apiKey string) (*resty.Response, error) <span class="cov8" title="1">{
        return s.client.R().
                SetAuthToken(apiKey).
                SetHeader("Content-Type", "application/json").
                SetHeader("HTTP-Referer", "https://github.com/alexandru-savinov/BalancedNewsGo").
                SetHeader("X-Title", "NewsBalancer").
                SetBody(map[string]interface{}{
                        "model": modelName,
                        "messages": []map[string]string{
                                {"role": "user", "content": prompt},
                        },
                }).
                Post(s.baseURL)
}</span>

// ScoreContent implements LLMService by making HTTP requests to score content
func (s *HTTPLLMService) ScoreContent(ctx context.Context, pv PromptVariant, art *db.Article) (score float64, confidence float64, err error) <span class="cov8" title="1">{
        // Try primary key first
        resp, err := s.callLLMAPIWithKey(pv.Model, pv.FormatPrompt(art.Content), s.apiKey)

        // Handle rate limiting and try backup key if available
        if (err != nil &amp;&amp; strings.Contains(err.Error(), "rate limit")) || (resp != nil &amp;&amp; resp.StatusCode() == 429) </span><span class="cov8" title="1">{
                if s.backupKey != "" </span><span class="cov8" title="1">{
                        // Try backup key if rate limited and backup key exists
                        resp, err = s.callLLMAPIWithKey(pv.Model, pv.FormatPrompt(art.Content), s.backupKey)
                        if (err != nil &amp;&amp; strings.Contains(err.Error(), "rate limit")) || (resp != nil &amp;&amp; resp.StatusCode() == 429) </span><span class="cov8" title="1">{
                                // Both keys are rate limited
                                return 0, 0, fmt.Errorf("rate limit exceeded on both keys: %w", ErrBothLLMKeysRateLimited)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // No backup key, propagate the original error
                        return 0, 0, fmt.Errorf("rate limit exceeded on primary key and no backup key provided")
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return 0, 0, err
        }</span>

        // Check for non-success status codes
        <span class="cov8" title="1">if resp.StatusCode() &gt;= 400 </span><span class="cov8" title="1">{
                return 0, 0, formatHTTPError(resp)
        }</span>

        // Parse the response
        <span class="cov8" title="1">score, _, confidence, err = parseNestedLLMJSONResponse(resp.String())
        return score, confidence, err</span>
}

// formatHTTPError formats a helpful error message from HTTP responses
func formatHTTPError(resp *resty.Response) error <span class="cov8" title="1">{
        return LLMAPIError{
                Message:      "HTTP error from LLM API",
                StatusCode:   resp.StatusCode(),
                ResponseBody: resp.String(),
        }
}</span>

// LLMAPIError represents an error from the LLM API service
type LLMAPIError struct {
        Message      string
        StatusCode   int
        ResponseBody string
}

// Error implements the error interface for LLMAPIError
func (e LLMAPIError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("LLM API Error (status %d): %s", e.StatusCode, e.Message)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
