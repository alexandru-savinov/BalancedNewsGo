# NewsBalancer Phase 3: Article Detail Page with SSE

## Article Detail Page ‚Äì Dynamic Analysis and SSE

The article detail view (`/article/:id`) provides the full article text and a detailed bias analysis. Upon initial load, the server has already embedded the article content and the latest bias analysis results into the HTML. This includes: the composite bias score (and corresponding label/color on the bias slider), the confidence level of that score, a short summary of the article, and possibly an initial breakdown of bias by perspective. The summary is generated by a background LLM ("summarizer") and stored in the database; the handler fetches it and injects it if available. Recent articles are listed in a sidebar for navigation/context.

**Re-Analysis Feature:** A key interactive element on the detail page is the ability to trigger a **re-analysis** of the article's bias. This is typically a button (e.g. "Reanalyze" or "Refresh Bias Score"). When clicked, the front-end sends a POST request to the backend endpoint **`POST /api/llm/reanalyze/:id`** with the article ID. This endpoint immediately enqueues re-analysis and returns 202 Accepted semantics. The backend logs and sets the initial progress state (status "InProgress") and then processes the LLM calls asynchronously.

**Progress via SSE:** As the re-analysis runs, the front-end opens an SSE connection to **`GET /api/llm/score-progress/:id`**. Each event contains a JSON payload with the current `step`, `percent`, `status`, and possibly `final_score`. When the status is "Complete", the SSE stream closes; the front-end then calls **`GET /api/articles/:id/bias`** to fetch the freshest composite score and update the UI.

## üîÑ SSE and Re-Analysis Verification

```powershell
# phase3_sse_reanalysis.ps1 - Executed after implementing article detail page with SSE
function Test-SSEAndReanalysis {
    Write-Host "üîç Testing SSE and reanalysis functionality..."
    
    # Start the server if not running
    $serverJob = Start-Process -FilePath "make" -ArgumentList "run" -NoNewWindow -PassThru
    Start-Sleep -Seconds 5  # Allow server to start
    
    try {
        # First, get an article ID to test with
        $articleId = Get-TestArticleId
        
        if (-not $articleId) {
            return @{
                success = $false
                error = "Could not find a valid article ID for testing"
            }
        }
        
        # Test the article detail page loads
        $detailPageResult = Test-ArticleDetailPage $articleId
        
        # Test reanalysis API endpoint
        $reanalysisResult = Test-ReanalysisEndpoint $articleId
        
        # Test SSE progress endpoint
        $sseResult = Test-SSEProgressEndpoint $articleId
        
        # Test bias API endpoint
        $biasResult = Test-BiasEndpoint $articleId
        
        $success = (
            $detailPageResult.success -and
            $reanalysisResult.success -and
            $sseResult.success -and
            $biasResult.success
        )
        
        return @{
            success = $success
            articleId = $articleId
            details = @{
                detailPage = $detailPageResult
                reanalysis = $reanalysisResult
                sseProgress = $sseResult
                biasEndpoint = $biasResult
            }
        }
    }
    finally {
        # Cleanup - stop the server
        if ($serverJob -ne $null) {
            Stop-Process -Id $serverJob.Id -Force -ErrorAction SilentlyContinue
        }
    }
}

function Get-TestArticleId {
    try {
        # Get articles listing and extract first article ID
        $response = Invoke-WebRequest -Uri "http://localhost:8080/articles" -UseBasicParsing
        
        # Try to extract article ID from links
        if ($response.Content -match '/article/(\d+)') {
            return $matches[1]
        }
        
        return $null
    }
    catch {
        return $null
    }
}

function Test-ArticleDetailPage {
    param([string]$articleId)
    
    try {
        # Test article detail page
        $response = Invoke-WebRequest -Uri "http://localhost:8080/article/$articleId" -UseBasicParsing
        
        # Check for expected elements
        $hasContent = $response.Content -match '<div\s+class=[''"]article-content[''"]'
        $hasBiasAnalysis = $response.Content -match '<div\s+class=[''"]bias-analysis[''"]'
        $hasReanalysisButton = $response.Content -match '<button[^>]*data-action=[''"]reanalyze[''"]'
        $hasBiasLabel = $response.Content -match '(Left Leaning|Center|Right Leaning)'
        
        return @{
            success = $hasContent -and $hasBiasAnalysis -and $hasReanalysisButton
            statusCode = $response.StatusCode
            hasContent = $hasContent
            hasBiasAnalysis = $hasBiasAnalysis
            hasReanalysisButton = $hasReanalysisButton
            hasBiasLabel = $hasBiasLabel
        }
    }
    catch {
        return @{
            success = $false
            error = $_.Exception.Message
        }
    }
}

function Test-ReanalysisEndpoint {
    param([string]$articleId)
    
    try {
        # Test reanalysis API endpoint
        $headers = @{
            "Content-Type" = "application/json"
        }
        
        $response = Invoke-WebRequest -Uri "http://localhost:8080/api/llm/reanalyze/$articleId" -Method Post -Headers $headers -UseBasicParsing
        
        # Check for 202 Accepted response
        $success = $response.StatusCode -eq 202
        
        return @{
            success = $success
            statusCode = $response.StatusCode
        }
    }
    catch {
        # Check if we got 202 but error parsing response
        if ($_.Exception.Response.StatusCode -eq 202) {
            return @{
                success = $true
                statusCode = 202
                note = "Got 202 status but could not parse response"
            }
        }
        
        return @{
            success = $false
            error = $_.Exception.Message
        }
    }
}

function Test-SSEProgressEndpoint {
    param([string]$articleId)
    
    # For SSE testing, we need to use a specialized approach
    # since PowerShell doesn't natively support SSE
    
    # Create a simple Node.js script to test SSE connection
    $sseTestScript = @"
const EventSource = require('eventsource');
const fs = require('fs');

const url = 'http://localhost:8080/api/llm/score-progress/$articleId';
const outputFile = 'sse_test_results.json';
console.log(`Testing SSE endpoint: ${url}`);

let events = [];
let connected = false;
let completed = false;
let error = null;

try {
  const eventSource = new EventSource(url);
  
  eventSource.onopen = () => {
    connected = true;
    console.log('SSE connection opened');
  };
  
  eventSource.onerror = (err) => {
    error = err.message || 'Unknown error';
    console.error('SSE error:', error);
    eventSource.close();
    writeResults();
  };
  
  eventSource.addEventListener('message', (event) => {
    try {
      const data = JSON.parse(event.data);
      events.push(data);
      console.log('Received event:', data);
      
      if (data.status === 'Complete') {
        completed = true;
        console.log('SSE stream completed');
        eventSource.close();
        writeResults();
      }
    } catch (e) {
      console.error('Error parsing event data:', e);
      events.push({ raw: event.data, error: e.message });
    }
  });
  
  // Timeout after 10 seconds to avoid hanging indefinitely
  setTimeout(() => {
    if (!completed) {
      console.log('SSE test timed out after 10 seconds');
      eventSource.close();
      writeResults();
    }
  }, 10000);
  
  function writeResults() {
    const results = {
      connected,
      completed,
      error,
      events,
      timestamp: new Date().toISOString()
    };
    fs.writeFileSync(outputFile, JSON.stringify(results, null, 2));
    console.log(`Results written to ${outputFile}`);
    
    // Force exit after writing results
    setTimeout(() => process.exit(), 500);
  }
} catch (e) {
  console.error('Failed to create EventSource:', e);
  fs.writeFileSync(outputFile, JSON.stringify({
    connected: false,
    error: e.message,
    timestamp: new Date().toISOString()
  }, null, 2));
}
"@
    
    # Write the test script to a temporary file
    $scriptPath = "sse_test.js"
    Set-Content -Path $scriptPath -Value $sseTestScript
    
    try {
        # Trigger reanalysis first to ensure there's progress to track
        Test-ReanalysisEndpoint $articleId | Out-Null
        
        # Run the Node.js script
        $nodeResult = node $scriptPath
        
        # Read the results
        $resultsPath = "sse_test_results.json"
        if (Test-Path $resultsPath) {
            $results = Get-Content $resultsPath | ConvertFrom-Json
            
            return @{
                success = $results.connected
                completed = $results.completed
                events = $results.events
                hasCorrectFormat = ($results.events | Where-Object { 
                    $_ -and $_.step -ne $null -and $_.percent -ne $null -and $_.status -ne $null 
                }).Count -gt 0
            }
        }
        else {
            return @{
                success = $false
                error = "Could not read SSE test results"
            }
        }
    }
    catch {
        return @{
            success = $false
            error = $_.Exception.Message
        }
    }
    finally {
        # Cleanup
        Remove-Item -Path $scriptPath -ErrorAction SilentlyContinue
        Remove-Item -Path "sse_test_results.json" -ErrorAction SilentlyContinue
    }
}

function Test-BiasEndpoint {
    param([string]$articleId)
    
    try {
        # Test bias API endpoint
        $response = Invoke-WebRequest -Uri "http://localhost:8080/api/articles/$articleId/bias" -UseBasicParsing
        
        # Parse response as JSON
        $content = $response.Content | ConvertFrom-Json
        
        # Check for expected fields
        $hasCompositeScore = $content.composite_score -ne $null
        $hasResults = $content.results -ne $null
        
        return @{
            success = $hasCompositeScore -and $hasResults
            statusCode = $response.StatusCode
            hasCompositeScore = $hasCompositeScore
            hasResults = $hasResults
        }
    }
    catch {
        return @{
            success = $false
            error = $_.Exception.Message
        }
    }
}

# Integration with feedback controller
$controller = [FeedbackController]::new()
$controller.Initialize()
$controller.UpdatePhase("article-detail-sse")

$result = Test-SSEAndReanalysis
if ($result.success) {
    $controller.CompletePhase("article-detail-sse")
    $controller.CurrentState.componentsStatus["sseReanalysis"] = "complete"
    $controller.SaveState()
    
    Write-Host "‚úÖ SSE and reanalysis tests passed successfully" -ForegroundColor Green
} else {
    Write-Host "‚ùå SSE and reanalysis tests failed" -ForegroundColor Red
    
    # Generate recommendations based on what failed
    $recommendations = @()
    if (-not $result.details.detailPage.success) {
        $recommendations += "Fix article detail page template - missing required elements"
    }
    if (-not $result.details.reanalysis.success) {
        $recommendations += "Fix reanalysis API endpoint (/api/llm/reanalyze/:id) - should return 202 Accepted"
    }
    if (-not $result.details.sseProgress.success) {
        $recommendations += "Fix SSE progress endpoint (/api/llm/score-progress/:id) - connection issues"
    }
    elseif (-not $result.details.sseProgress.hasCorrectFormat) {
        $recommendations += "Fix SSE event format - should include step, percent, and status fields"
    }
    if (-not $result.details.biasEndpoint.success) {
        $recommendations += "Fix bias API endpoint (/api/articles/:id/bias) - missing required fields"
    }
    
    foreach ($rec in $recommendations) {
        Write-Host "  - $rec" -ForegroundColor Yellow
    }
    
    $controller.LogIssue("sseReanalysis", "SSE and reanalysis functionality failed", "critical")
}
```

## Implementation Details

### Article Detail Page Structure
The article detail page should include:
1. Full article content
2. Detailed bias analysis section showing:
   - Composite bias score
   - Confidence level
   - Bias label ("Left Leaning", "Center", "Right Leaning")
   - Bias slider visualization
   - Article summary (if available)
3. Reanalysis button to trigger new analysis
4. Sidebar with recent articles for navigation
5. Progress indicator for ongoing analysis

### Server-Sent Events (SSE) Implementation
The SSE implementation should:
1. Use standard EventSource API on the client side
2. Return events with proper Content-Type: text/event-stream
3. Include JSON payload with step, percent, and status fields
4. Close the connection when analysis is complete
5. Handle client disconnection gracefully

### SSE Event Format
```json
{
  "step": "Processing article with LLM models",
  "percent": 45,
  "status": "InProgress"
}
```
or when complete:
```json
{
  "step": "Analysis complete",
  "percent": 100,
  "status": "Complete",
  "final_score": 0.25
}
```

### JavaScript Client Implementation
```javascript
// Example client-side JavaScript for handling SSE
function startReanalysis(articleId) {
  // First trigger reanalysis
  fetch(`/api/llm/reanalyze/${articleId}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' }
  })
  .then(response => {
    if (response.status === 202) {
      // Start monitoring progress
      monitorProgress(articleId);
    }
  })
  .catch(error => console.error('Error starting reanalysis:', error));
}

function monitorProgress(articleId) {
  const progressElement = document.getElementById('analysis-progress');
  progressElement.style.display = 'block';
  
  const eventSource = new EventSource(`/api/llm/score-progress/${articleId}`);
  
  eventSource.onmessage = function(event) {
    const data = JSON.parse(event.data);
    progressElement.innerText = `${data.step} (${data.percent}%)`;
    
    if (data.status === 'Complete') {
      eventSource.close();
      // Fetch the updated bias score
      updateBiasDisplay(articleId);
    }
  };
  
  eventSource.onerror = function() {
    eventSource.close();
    progressElement.innerText = 'Error monitoring progress';
  };
}

function updateBiasDisplay(articleId) {
  fetch(`/api/articles/${articleId}/bias`)
    .then(response => response.json())
    .then(data => {
      // Update UI with new bias score
      document.getElementById('composite-score').innerText = data.composite_score.toFixed(2);
      // Update other UI elements as needed
    })
    .catch(error => console.error('Error fetching updated bias:', error));
}
```

### Backend Implementation
The Go backend should implement:
1. `TemplateArticleHandler` to render the article detail page
2. `POST /api/llm/reanalyze/:id` endpoint to trigger analysis
3. `GET /api/llm/score-progress/:id` endpoint for SSE updates
4. `GET /api/articles/:id/bias` endpoint to fetch latest results

## Verification Process
The automated verification script tests:
1. Article detail page structure and required elements
2. Reanalysis API endpoint functionality and proper 202 response
3. SSE progress endpoint connection and event format
4. Bias API endpoint response format

Each test verifies both the correct HTTP status code and the presence of expected fields in the response, ensuring that the SSE implementation and related endpoints function correctly.
